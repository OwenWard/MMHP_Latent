---
title: "Diagnostics Week of June 28th"
author: "Owen Ward"
date: "6/30/2020"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
    code_folding: hide
---

The aim of this script is to further investigate model fit by better diagnosttic
plots for mice pairs in a specific window.

```{r setup, include=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)

data_path <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_prior/"

func_dir <- "../lib/"

library(rstan)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
options(mc.cores = parallel::detectCores())
library(tidyverse)
library(R.utils)
library(fields)
library(bayesplot)
library(compete)
library(RColorBrewer)
source(paste(func_dir,'naiveRankHierarchy.R',sep = ""))
source(paste(func_dir,'expertRankHierarchy.R',sep = ""))
source(paste(func_dir,'cleanData.R',sep = "")) 
source(paste(func_dir,'prepareDataStan.R',sep = "")) 
source(paste(func_dir,'inferLatentMmhp.R',sep = ""))
source(paste(func_dir,'plotUtil.R',sep = "")) 
source(paste(func_dir,'mmhp.R',sep = ""))
source(paste(func_dir,'uniHawkes.R',sep = ""))
source(paste(func_dir,'simulatePrediction.R',sep = ""))
source(paste(func_dir,'myGlicko.R',sep = ""))
source(paste(func_dir,'matrixPlotParameter.R',sep = ""))
source(paste(func_dir,'residualStructureScore.R',sep = ""))
source("https://gist.githubusercontent.com/jalapic/6ca3ece44bdcdc522bb735f183aa0ca0/raw/1a07f469eff08117121b6cbebcd22fb7569e3ee8/compete_extra.R")


source("C:/Users/owenw/Dropbox/with Owen/code/part3/lib/intensityPlot.R")
source("C:/Users/owenw/Dropbox/with Owen/code/part3/lib/uniHawkes.R")

theme_set(theme_minimal())

model1_fn <- list(alpha.fun = function(x,y,eta1,eta2,eta3){return(eta1*x*y*exp(-eta2*abs(x-y))/(1+exp(-eta3*(x-y))))})


c_mmhp_path <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_folders/output_june30/"

other_path  <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_null_windows/"
old_data_path  <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_null_windows/"

```


```{r mice_setup,include=FALSE,echo=FALSE, cache=TRUE}
cohort_names <- paste("cohort",c(9,10,12,15,16,17,18,37,38,45),sep='')
cohort_short_names <- paste("C",c(9,10,12,15,16,17,18,37,38,45),sep='')
cut_off <- 3
mice_number <- 12

full_data <- readRDS("../data/mice.RData")
# A=c9, B=c10, C=c12, D=c15, E=c16, F=c17, G=c18, H=c37, I=c38. J=c45
cohort_names <- paste("cohort",c(9,10,12,15,16,17,18,37,38,45),sep='')
cohort_short_names <- paste("C",c(9,10,12,15,16,17,18,37,38,45),sep='')
cut_off <- 3
mice_number <- 12

# Define the cohorts will be fitted
fit_cohorts <- c(1:10)
naive_rank_10 <- list()
expert_rank_10 <- list()
for(current_cohort in fit_cohorts){
  naive_rank_10[[current_cohort]] <- naiveRankHierarchy(full_data[[cohort_names[current_cohort]]])
  expert_rank_10[[current_cohort]] <- expertRankHierarchy(full_data[[cohort_names[current_cohort]]])
}


```


# Correction to Pair level rates

A previous bug with C-MMHP was not correctly accounting for the degree corrected `lambda0` and corresponding
`lambda1` between each pair when interpolating the latent states and then identifying the residual matrices. 
We first want to check the effect this has.



```{r}
# output for this correction stored in output_folders/output_june_30 for c_mmhp, others haven't changed

c_mmhp_path <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_folders/output_june30/"

other_path  <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_null_windows/"

cohorts <- 1:10
#cohorts <- cohorts[c(-1,-3,-5,-6,-7)] # these did not run on the cluster in time

for(current_cohort in cohorts) {
  m1_pr <- readRDS(paste(other_path,cohort_names[current_cohort],
                     "/chp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

  m2_pr <- readRDS(paste(other_path,cohort_names[current_cohort],
                       "/dchp_pr_matrix_",cohort_names[current_cohort],
                       ".RDS",sep=''))
  
  m3_pr <- readRDS(paste(c_mmhp_path,cohort_names[current_cohort],
                       "/cmmhp_pr_matrix_",cohort_names[current_cohort],
                       ".RDS",sep=''))
  
  indep_pr <- readRDS(paste(other_path,cohort_names[current_cohort],
                       "/immhp_pr_matrix_",cohort_names[current_cohort],
                       ".RDS",sep=''))
  
  matrix_lst_plot <- list(
                          indep_pr[rev(expert_rank_10[[current_cohort]]),
                                                                     expert_rank_10[[current_cohort]]],
                          m1_pr[rev(expert_rank_10[[current_cohort]]),
                                                                   expert_rank_10[[current_cohort]]],
                          m2_pr[rev(expert_rank_10[[current_cohort]]),
                                                                   expert_rank_10[[current_cohort]]],
                          m3_pr[rev(expert_rank_10[[current_cohort]]),
                                                                   expert_rank_10[[current_cohort]]]) 
  myMultiMatrixPlot(X=matrix_lst_plot,no_matrix=4,n_row=2,
                    xLabels=expert_rank_10[[current_cohort]],
                    yLabels=rev(expert_rank_10[[current_cohort]]),
                    min=-60,max=60,axis_cex=2,title_cex = 1.8,
                    colorPalette="RdBu",if.emp=FALSE,
                    #legend.mar=c(0.5,.5,0.5,0.5),
                    title_lst=list("I-MMHP","C-HP","C-DCHP","DC C-MMHP"), 
                    #title_lst = list("I-MMHP"),
                    col_axis=c(-60,-30,0,30,60), fake_matrix=FALSE,
                    matrix.mar=c(2.5,2.5,2.5,1)
                    )
}



```






# Examine Intensity and QQ Plot

To do these plots we need to compute the compensators for these models. Using the second
cohort as we have all results for it.

```{r compute diagnostics for single cohort, cache=TRUE, include=FALSE}
current_cohort <- 2
no_segments <- 500 # to run a little faster


old_data_path <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_null_windows/"

c_mmhp_path <- "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/output_folders/output_june30/"

clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("observe.id","observe.time")])


## cmmhp ####
load(paste(c_mmhp_path, cohort_names[current_cohort],
           "/cohort_mmhp_stan_result_", cohort_names[current_cohort],".RData",sep=''))
load(paste(c_mmhp_path,cohort_names[current_cohort],
           "/cmmhp_est_zt_",cohort_names[current_cohort],".RData",sep=''))


raw_real_cmmhp_vec  <- numeric(0)
pr_real_cmmhp_vec <- numeric(0)
Lambda_cmmhp_matrix <- matrix(rep(list(),mice_number*mice_number),
                             nrow=mice_number, ncol=mice_number)

real_N_vec <- numeric(0)
#no_segments <- 500
for(i in 1:mice_number){
  print(i)
  for(j in 1:mice_number){
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0&(i!=j)){
      par_est <- list(lambda0=mean(sim_cohort_mmhp$lambda0[,pair]),
                      lambda1=mean(sim_cohort_mmhp$lambda1[,pair]),
                      alpha=mean(sim_cohort_mmhp$alpha[,pair]),
                      beta=mean(sim_cohort_mmhp$beta),
                      q1=mean(sim_cohort_mmhp$q1[,pair]),
                      q2=mean(sim_cohort_mmhp$q2[,pair]))
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_rescaled_interevent <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ 
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                          return_df$recipient==j&
                                          return_df$observe.id==cur_win,"event.times"][[1]]
        current_obs_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                                        return_df$observe.id==cur_win,"observe.time"]
        time_segment <- seq(0,current_obs_time,length.out=no_segments)
        latent_mean <- apply(interpolation_array_list[[pair]][[cur_win]],1,mean)
        latent_event <- as.numeric(apply(2-state_array_list[[pair]][[cur_win]],1,mean) > 0.5) 
        
        ## Pearson
        est.intensity <- mmhpIntensityNumeric(params=par_est,
                                              t=current_event_time,
                                              time.vec=time_segment,
                                              latent.vec=latent_mean)
        est.intensity.events <- mmhpIntensityAtEvents(params=par_est, t=current_event_time,
                                                      latent_z=latent_event)
        all_prresidual <- sum(1/sqrt(est.intensity.events))-
          sum(sqrt(est.intensity))*(time_segment[2]-time_segment[1])
        all_Lambda <- sum(est.intensity)*(time_segment[2]-time_segment[1])
        
        ## rescaled interevent time
        Lambda_vec <- rep(0,length(current_event_time)+1)
        temp_time_vec <- c(0,current_event_time,current_obs_time)
        for(m in 1:(length(current_event_time)+1)){
          interevent_idx <- (time_segment>=temp_time_vec[m]) & (time_segment<temp_time_vec[m+1])
          Lambda_vec[m] <- sum(est.intensity[interevent_idx])*(time_segment[2]-time_segment[1])
        }
        real_N_vec <- c(real_N_vec, length(current_event_time))
        raw_real_cmmhp_vec <- c(raw_real_cmmhp_vec,all_Lambda)
        pr_real_cmmhp_vec <- c(pr_real_cmmhp_vec,all_prresidual)
        all_rescaled_interevent <- c(all_rescaled_interevent,Lambda_vec)
      }  
      Lambda_cmmhp_matrix[i,j][[1]] <- all_rescaled_interevent
    }
  }
}

rm(interpolation_array_list)
rm(state_array_list)


## cohort hawkes ####
raw_real_c_hawkes_vec  <- numeric(0)
pr_real_c_hawkes_vec <- numeric(0)
Lambda_c_hawkes_matrix <- matrix(rep(list(),mice_number*mice_number),
                               nrow=mice_number, ncol=mice_number)


load(paste(old_data_path, cohort_names[current_cohort],
           "/cohort_hp_stan_result_", cohort_names[current_cohort],".RData",sep=''))

# create a list to store the hawkes parameters for this
model1_par_est <- list(lambda0=mean(sim_cohort_hp$lambda0),
                       eta_1=mean(sim_cohort_hp$eta_1),
                       eta_2=mean(sim_cohort_hp$eta_2),
                       eta_3=mean(sim_cohort_hp$eta_3),
                       beta=mean(sim_cohort_hp$beta),
                       f=apply(sim_cohort_hp$f,2,mean))
model1_par_matrix <- list(lambda0_matrix=matrix(model1_par_est$lambda0,
                                                nrow=mice_number,ncol=mice_number),
                          alpha_matrix=formMatrix(function(x,y) model1_fn$alpha.fun(x,y,
                                                                                    model1_par_est$eta_1,
                                                                                    model1_par_est$eta_2,
                                                                                    model1_par_est$eta_3),
                                                  model1_par_est$f),
                          beta_matrix=matrix(model1_par_est$beta,
                                             nrow=mice_number,ncol=mice_number))



for(i in 1:mice_number){
  print(i)
  for(j in 1:mice_number){
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0&(i!=j)){
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_rescaled_interevent <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ 
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                                        return_df$observe.id==cur_win,"event.times"][[1]]
        observe_period <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                                        return_df$observe.id==cur_win,"observe.time"]
        #### update this from the stan fit
        hawkes.par <- c(model1_par_matrix$lambda0_matrix[i,j],model1_par_matrix$alpha[i,j],
                        model1_par_matrix$beta[i,j])
        # hawkes.par <- optim(par=c(1,0,100), fn=uniHawkesNegLogLik, method="CG", 
        #                     t=current_event_time, termination = observe_period)
        all_Lambda <- uniHawkesIntegralIntensity(object=list(lambda0=hawkes.par[1],
                                                              alpha=hawkes.par[2],
                                                              beta=hawkes.par[3]),
                                                  events=current_event_time,
                                                  termination = observe_period)
        all_prresidual <- uniHawkesPearsonResidual(object=list(lambda0=hawkes.par[1],
                                                              alpha=abs(hawkes.par[2]),
                                                              beta=hawkes.par[3]),
                                                  events=current_event_time,
                                                  termination = observe_period)

        ## rescaled interevent time
        Lambda_vec <- uniHawkesCompensator(lambda0=hawkes.par[1],
                                           alpha=hawkes.par[2],
                                           beta=hawkes.par[3],
                                           c(0,current_event_time))
        all_rescaled_interevent <- c(all_rescaled_interevent,Lambda_vec)
        raw_real_c_hawkes_vec <- c(raw_real_c_hawkes_vec,all_Lambda)
        pr_real_c_hawkes_vec <- c(pr_real_c_hawkes_vec,all_prresidual)
      }
      Lambda_c_hawkes_matrix[i,j][[1]] <- all_rescaled_interevent
    }
  }
}


## cohort degree corrected hawkes ####
raw_real_dc_hawkes_vec  <- numeric(0)
pr_real_dc_hawkes_vec <- numeric(0)
Lambda_dc_hawkes_matrix <- matrix(rep(list(),mice_number*mice_number),
                               nrow=mice_number, ncol=mice_number)

# model1_fn <- list(alpha.fun = function(x,y,eta1,eta2,eta3){return(eta1*x*y*exp(-eta2*abs(x-y))/(1+exp(-eta3*(x-y))))})


load(paste(old_data_path, cohort_names[current_cohort],
           "/cohort_dchp_stan_result_", cohort_names[current_cohort],".RData",sep=''))

# create a list to store the hawkes parameters for this
model2_par_est <- list(gamma = apply(sim_cohort_dchp$gamma,2,mean),
                       zeta = apply(sim_cohort_dchp$zeta,2,mean),
                       #lambda0=mean(sim_cohort_dchp$lambda0),
                       eta_1=mean(sim_cohort_dchp$eta_1),
                       eta_2=mean(sim_cohort_dchp$eta_2),
                       eta_3=mean(sim_cohort_dchp$eta_3),
                       beta=mean(sim_cohort_dchp$beta),
                       f=apply(sim_cohort_dchp$f,2,mean))
model2_par_matrix <- list(lambda0_matrix= outer(model2_par_est$gamma,
                                                model2_par_est$zeta,FUN = "+"),
                          alpha_matrix=formMatrix(function(x,y) model1_fn$alpha.fun(x,y,
                                                                                    model2_par_est$eta_1,
                                                                                  model2_par_est$eta_2,
                                                                                    model2_par_est$eta_3),
                                                  model2_par_est$f),
                          beta_matrix=matrix(model2_par_est$beta,
                                             nrow=mice_number,ncol=mice_number))



for(i in 1:mice_number){
  print(i)
  for(j in 1:mice_number){
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0&(i!=j)){
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_rescaled_interevent <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ 
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                                        return_df$observe.id==cur_win,"event.times"][[1]]
        observe_period <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                                        return_df$observe.id==cur_win,"observe.time"]
        #### update this from the stan fit
        hawkes.par <- c(model2_par_matrix$lambda0_matrix[i,j],model2_par_matrix$alpha[i,j],
                        model2_par_matrix$beta[i,j])
        # hawkes.par <- optim(par=c(1,0,100), fn=uniHawkesNegLogLik, method="CG", 
        #                     t=current_event_time, termination = observe_period)
        all_Lambda <- uniHawkesIntegralIntensity(object=list(lambda0=hawkes.par[1],
                                                              alpha=hawkes.par[2],
                                                              beta=hawkes.par[3]),
                                                  events=current_event_time,
                                                  termination = observe_period)
        all_prresidual <- uniHawkesPearsonResidual(object=list(lambda0=hawkes.par[1],
                                                              alpha=abs(hawkes.par[2]),
                                                              beta=hawkes.par[3]),
                                                  events=current_event_time,
                                                  termination = observe_period)

        ## rescaled interevent time
        Lambda_vec <- uniHawkesCompensator(lambda0=hawkes.par[1],
                                           alpha=hawkes.par[2],
                                           beta=hawkes.par[3],
                                           c(0,current_event_time))
        all_rescaled_interevent <- c(all_rescaled_interevent,Lambda_vec)
        raw_real_dc_hawkes_vec <- c(raw_real_dc_hawkes_vec,all_Lambda)
        pr_real_dc_hawkes_vec <- c(pr_real_dc_hawkes_vec,all_prresidual)
      }
      Lambda_dc_hawkes_matrix[i,j][[1]] <- all_rescaled_interevent
    }
  }
}

# save(raw_real_hawkes_vec, pr_real_hawkes_vec,Lambda_hawkes_matrix,
#      raw_real_mmpp_vec, pr_real_mmpp_vec, Lambda_mmpp_matrix,
#      raw_real_mmhpsd_vec, pr_real_mmhpsd_vec, Lambda_mmhpsd_matrix,
#      file = "../output/real_diag_four_models.RData")
```




This is for a specific pair in a single window, we want to plot these three models.


```{r select cohort pair window}
no_segments <- 500

current_cohort <- 4#5
current_i <- 2 #8
current_j <- 8 #2
current_win <- 42
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
            observe=list(observe.id),
            observe.length=list(observe.time),
            no.events=list(no.events))
pair <- which(unique_pairs_df$initiator==current_i&unique_pairs_df$recipient==current_j)
unique_observe_win <- unique(return_df[,c("observe.id","observe.time")])

row_indicator <- return_df$initiator==current_i&return_df$recipient==current_j&return_df$observe.id==current_win
row_idx <- which(return_df$initiator==current_i&return_df$recipient==current_j&return_df$observe.id==current_win)
current_event_time <- return_df[row_indicator,"event.times"][[1]]
observe_period <- return_df[row_indicator,"observe.time"]
#no_segments <- 500
time_segment <- seq(0,observe_period,length.out=no_segments)

```


Then we can plot some of these fits.


```{r plot_functions, include=FALSE}
drawRealIntensityPaper <- function(t,
                                   object=NULL,simulation=NULL,
                                   yupper=10,add=FALSE,color=1,line.width=1,
                                 title_name="",title.cex=9, y.ratio=0,
                                 min.y=0, min.x=0, max.x=NULL, 
                                 annotate.time=FALSE,
                                 event.cex=1, box.type="l",
                                 box.col="gray40", title.line=1){
  # input object: the parameter list used for generating mmhp
  #       simulation: simulation result from simulate.mmhp 
  if(t[1]>0){
    t <- c(0,t)
  }
  if(is.null(max.x)){
    max.x <- tail(t,1)
  }
  if(is.null(object)){
    termination <- tail(t,1)
    n <- length(t)
    plot(0,0,xlim=c(min.x,max.x),ylim=c(min.y,yupper*(1+y.ratio)),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    box(lty ='solid', col=box.col, lwd=0.7, bty=box.type)
    title(title_name,line=title.line,cex.main=title.cex)
    #left axes
    #axis(2,at=seq(0,yupper,5),labels=FALSE,cex.lab=2,lwd=0,lwd.ticks=1) 
    #text(-termination/50, y=seq(0,yupper,5), labels=seq(0,yupper,5), cex=1.6, srt=0, xpd=TRUE)
    #bottom axes
    # events
    points(t[-1],rep(min.y,n-1),cex=event.cex,pch=16,col="black")
  }else{
    state <- simulation$z
    state_time <- simulation$x
    if(tail(state_time,1)<tail(t,1)){
      state_time <- c(state_time,tail(t,1))
      state <- c(state,3-tail(state,1))
    }
    lambda0 <- object$lambda0
    lambda1 <- object$lambda1
    alpha <- object$alpha
    beta <- object$beta
    termination <- tail(t,1)
    n <- length(t)
    m <- length(state)
    if(is.null(min.y)){
      min.y <- -lambda0
    }
    if(is.null(max.x)){
      max.x <- termination
    }
    #plot(1,4,xlim=c(0.27,23),ylim=c(-0.5,9), type="n",xlab="Time",ylab="",xaxt="n",yaxt="n",cex.lab=1.8,bty="n")
    
    if(add==FALSE){
      plot(0,0,xlim=c(min.x,max.x),ylim=c(min.y,yupper*(1+y.ratio)),
           type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
      box(lty ='solid', col=box.col, lwd=0.7, bty=box.type)
      title(title_name,line=title.line,cex.main=title.cex)
      #left axes
      #axis(2,at=seq(0,yupper,5),labels=FALSE,cex.lab=2,lwd=0,lwd.ticks=1) 
      #text(-termination/50, y=seq(0,yupper,5), labels=seq(0,yupper,5), cex=1.6, srt=0, xpd=TRUE)
      #bottom axes
      if(annotate.time){
        axis(1,at=seq(0,ceiling(termination),length.out=5),labels=FALSE,cex.lab=2,lwd=0,lwd.ticks=1) #bottom axes
        text(seq(0,ceiling(termination),length.out=5), y=-y.ratio*6, cex=1.7, srt=0, xpd=TRUE,
             labels=round(seq(0,ceiling(termination),length.out=5),0))
      }
      # events
      points(t[-1],rep(min.y,n-1),cex=event.cex,pch=16,col="black")
    }
    
    if(m==2&state[1]==1&state_time[2]==tail(t,1)){
      drawHawkesIntensityPaper(lambda0,alpha,beta,t,color=color,
                               line.width=line.width)
    }else{
      for(i in 1:(m-1)){
        if(state[i]==1){
          hawkes_time <- t[t>=state_time[i]&t<=state_time[i+1]]
          if(i==1) hawkes_time <- hawkes_time[-1]
          history <- t[t<state_time[i]]
          # bug here
          drawHawkesIntensityPaper(lambda0 =lambda1,
                                   #i,
                                   alpha = alpha,
                                   beta = beta,
                                   #state_time[i],
                                   #state_time[i+1],
                                   #history[-1],
                                   events = hawkes_time,
                                   color=color,line.width=line.width)
        }else{
          segments(x0=state_time[i],x1=state_time[i+1], y0=lambda0,
                   lty=1,col=color,lwd=line.width)
        }
        if(i>1){
          segments(x0=state_time[i],y0=lambda0, y1=lambda1, lty=2, col=color,lwd=line.width)
        }
      }
    }
  }
}


drawHawkesIntensityPaper <- function(lambda0,alpha,beta,
                                     events,color=1,line.width=2, termination=NULL){
  # input object: parameters for Hawkes process, include lambda0, alpha, beta 
  #       events: vector of event happening time
  horizon <- tail(events,1)
  events <- events[events>0]
  N <- length(events)
  
  if(N==1){ # only one event condition
    segments(x0=0, x1=events[1], y0=lambda0, col=color,lwd=line.width)
    segments(x0=events[1], y0=lambda0, y1=lambda0+alpha, col=color,lwd=line.width)
    if(horizon > tail(events,1)){
      lambda.n <- function(s) lambda0+alpha*sum(exp(-beta*(s-events[1])))
      new.lambda.n<-Vectorize(lambda.n)
      curve(new.lambda.n, from=tail(events,1), to=horizon, add=TRUE, col=color,lwd=line.width)
    }
    #if( !is.null(title) ) title(main=title)
  }else{
    segments(x0=0, x1=events[1], y0=lambda0, col=color,lwd=line.width)
    segments(x0=events[1], y0=lambda0, y1=lambda0+alpha, col=color,lwd=line.width)
    
    for(i in 1:(N-1)){
      lambda.n <- function(s) lambda0+alpha*sum(exp(-beta*(rep(s,i)-events[1:i])))
      new.lambda.n<-Vectorize(lambda.n)
      curve(new.lambda.n, from=events[i], to=events[i+1], add=TRUE, col=color,lwd=line.width)
      segments(x0=events[i+1],y0=lambda.n(events[i+1]),y1=lambda.n(events[i+1])+alpha, col=color,lwd=line.width)
    }
  }
  if(!is.null(termination)){
    lambda.n <- function(s) lambda0+alpha*sum(exp(-beta*(rep(s,N)-events[1:N])))
    new.lambda.n<-Vectorize(lambda.n)
    curve(new.lambda.n, from=events[N], to=termination, add=TRUE, col=color,lwd=line.width)
  }
}



```




```{r plot intensity in a window, fig.width=10}
y.upper <- 20
title.line <- 1
title.cex <- 1
anno.cex <- 1

## Cohort Hawkes ####
# load the parameters for this pair
load(paste(old_data_path, cohort_names[current_cohort],
           "/cohort_hp_stan_result_", cohort_names[current_cohort],".RData",sep=''))

# create a list to store the hawkes parameters for this
model1_par_est <- list(lambda0=mean(sim_cohort_hp$lambda0),
                       eta_1=mean(sim_cohort_hp$eta_1),
                       eta_2=mean(sim_cohort_hp$eta_2),
                       eta_3=mean(sim_cohort_hp$eta_3),
                       beta=mean(sim_cohort_hp$beta),
                       f=apply(sim_cohort_hp$f,2,mean))
model1_par_matrix <- list(lambda0_matrix=matrix(model1_par_est$lambda0,
                                                nrow=mice_number,ncol=mice_number),
                          alpha_matrix=formMatrix(function(x,y) model1_fn$alpha.fun(x,y,
                                                                                    model1_par_est$eta_1,
                                                                                    model1_par_est$eta_2,
                                                                                    model1_par_est$eta_3),
                                                  model1_par_est$f),
                          beta_matrix=matrix(model1_par_est$beta,
                                             nrow=mice_number,ncol=mice_number))

hawkes.par <- c(model1_par_matrix$lambda0_matrix[current_i,current_j],
                model1_par_matrix$alpha[current_i,current_j],
                        model1_par_matrix$beta[current_i,current_j])

drawRealIntensityPaper(current_event_time,
                       yupper=y.upper, color="black",line.width=2,title.line=title.line,
                       title_name="Cohort Hawkes",
                       title.cex=title.cex, max.x=observe_period, box.col="black")
drawHawkesIntensityPaper(lambda0=hawkes.par[1],
                         alpha=hawkes.par[2],
                         beta=hawkes.par[3],
                         events=current_event_time, termination=observe_period)
mtext(side=1, text="Time", line=1.6, cex=anno.cex)
mtext(side=2, text="Intensity", line=1.2, cex=anno.cex)


#### Degree Corrected Hawkes ####
load(paste(old_data_path, cohort_names[current_cohort],
           "/cohort_dchp_stan_result_", cohort_names[current_cohort],".RData",sep=''))

# create a list to store the hawkes parameters for this
model2_par_est <- list(gamma = apply(sim_cohort_dchp$gamma,2,mean),
                       zeta = apply(sim_cohort_dchp$zeta,2,mean),
                       #lambda0=mean(sim_cohort_dchp$lambda0),
                       eta_1=mean(sim_cohort_dchp$eta_1),
                       eta_2=mean(sim_cohort_dchp$eta_2),
                       eta_3=mean(sim_cohort_dchp$eta_3),
                       beta=mean(sim_cohort_dchp$beta),
                       f=apply(sim_cohort_dchp$f,2,mean))
model2_par_matrix <- list(lambda0_matrix= outer(model2_par_est$gamma,
                                                model2_par_est$zeta,FUN = "+"),
                          alpha_matrix=formMatrix(function(x,y) model1_fn$alpha.fun(x,y,
                                                                                    model2_par_est$eta_1,
                                                                                  model2_par_est$eta_2,
                                                                                    model2_par_est$eta_3),
                                                  model2_par_est$f),
                          beta_matrix=matrix(model2_par_est$beta,
                                             nrow=mice_number,ncol=mice_number))

hawkes.par <- c(model2_par_matrix$lambda0_matrix[current_i,current_j],
                model2_par_matrix$alpha[current_i,current_j],
                model2_par_matrix$beta[current_i,current_j])

drawRealIntensityPaper(current_event_time,
                       yupper=y.upper, color="black",line.width=2,title.line=title.line,
                       title_name="Cohort DC-Hawkes",
                       title.cex=title.cex, max.x=observe_period, box.col="black")
drawHawkesIntensityPaper(lambda0=hawkes.par[1],
                         alpha=hawkes.par[2],
                         beta=hawkes.par[3],
                         events=current_event_time, termination=observe_period)
mtext(side=1, text="Time", line=1.6, cex=anno.cex)
mtext(side=2, text="Intensity", line=1.2, cex=anno.cex)


rm(fit_cohort_hp)
rm(fit_cohort_dchp)
rm(sim_cohort_hp)
rm(sim_cohort_dchp)

```


This ouput is correctly dealing with the C-MMHP parameters now.


```{r draw_mmhp_fit}
#current_cohort <- 2
## Cohort MMHP
load(paste(c_mmhp_path,cohort_names[current_cohort],
             "/cohort_mmhp_stan_result_",cohort_names[current_cohort],
             ".RData",sep=''))
load(paste(c_mmhp_path,cohort_names[current_cohort],
             "/cmmhp_est_zt_",cohort_names[current_cohort],".RData",sep=''))

# then adjust the parameters for c-mmhp below here also

mmhp_par <- list(lambda1=mean(sim_cohort_mmhp$lambda1[,pair]),
                 lambda0=mean(sim_cohort_mmhp$lambda0[,pair]),
                 alpha=mean(sim_cohort_mmhp$alpha[,pair]),
                 beta=mean(sim_cohort_mmhp$beta),
                 q1=mean(sim_cohort_mmhp$q1[,pair]),
                 q2=mean(sim_cohort_mmhp$q2[,pair]))

mmhp.est.latent <- ifelse(apply(state_array_list[[pair]][[current_win]],1,function(x) sum(x==1)) >500,rep(1,1000),rep(2,1000))
mmhp.est.latent <- interpolateLatentTrajectory(params=mmhp_par,events=current_event_time,zt=mmhp.est.latent,
                                               initial.state=mean(initial_state_list[[pair]][[current_win]]),
                                               termination.time=observe_period,termination.state = 2)

drawRealIntensityPaper(current_event_time, object=mmhp_par,title.line=title.line,
                       simulation=list(x=c(0,mmhp.est.latent$x.hat),
                                       z=mmhp.est.latent$z.hat),
                       yupper=y.upper, color="black", line.width=2,
                       title_name="Cohort MMHP", title.cex=title.cex, max.x=observe_period, box.col="black")
mtext(side=1, text="Time", line=1.6, cex=anno.cex)
mtext(side=2, text="Intensity", line=1.2, cex=anno.cex)

rm(interpolation_array_list)
rm(state_array_list)
rm(initial_state_list)
rm(termination_state_list)

```


```{r, eval=FALSE}
#y.upper <- 10
#title.line <- 1
#title.cex <- 0.1
drawRealIntensityPaper(current_event_time, object=mmhp_par,title.line=title.line,
                       simulation=list(x=c(0,mmhp.est.latent$x.hat),
                                       z=mmhp.est.latent$z.hat),
                       yupper=y.upper, color="black", line.width=2,
                       title_name="MMHP", title.cex=title.cex, max.x=observe_period, box.col="black")
mtext(side=1, text="Time", line=1.6, cex=anno.cex)
mtext(side=2, text="Intensity", line=1.2, cex=anno.cex)

```

The corresponding QQ plots also.
These need to be updated to account for the full diagnostic output which now
exists.


```{r, eval=FALSE}
anno.cex <- 1
#### Hawkes
Lambda.hawkes.test <- Lambda_hawkes_matrix[current_i,current_j][[1]]

p <- ppoints(length(Lambda.hawkes.test))    # 100 equally spaced points on (0,1), excluding endpoints
q <- quantile(Lambda.hawkes.test,p=p,na.rm=TRUE) # percentiles of the sample distribution
plot(qexp(p),q, 
     xlab="",ylab="",xaxt="n",yaxt="n",
     pch=1,cex=1,col="Black",ylim=c(0,8),xlim=c(0,5))
mtext(side=1, text="Theoretical Quantiles", line=1.6, cex=anno.cex)
mtext(side=2, text="Empirical Quantiles", line=1.2, cex=anno.cex)
Hmisc::mgp.axis(1,mgp=c(0,0.1,0),at=c(0:8),cex.axis=1,lwd=0,lwd.ticks=1)
Hmisc::mgp.axis(2,mgp=c(0,0.1,0),at=c(0:8),cex.axis=1,lwd=0,lwd.ticks=1)
qqline(q, distribution=qexp,col="Black", lty=1, lwd=2.5)





#### mmhp
Lambda.test.mmhp <- Lambda_mmhp_matrix[current_i,current_j][[1]]
p <- ppoints(length(Lambda.test.mmhp))    # 100 equally spaced points on (0,1), excluding endpoints
q <- quantile(Lambda.test.mmhp,p=p,na.rm=TRUE) # percentiles of the sample distribution
plot(qexp(p),q, 
     xlab="",ylab="",xaxt="n",yaxt="n",
     pch=1,cex=1,col="Black",ylim=c(0,max(q)),xlim=c(0,3))
mtext(side=1, text="Theoretical Quantiles", line=1.6, cex=anno.cex)
mtext(side=2, text="Empirical Quantiles", line=1.2, cex=anno.cex)
Hmisc::mgp.axis(1,mgp=c(0,0.1,0),at=c(0:5),cex.axis=1,lwd=0,lwd.ticks=1)
Hmisc::mgp.axis(2,mgp=c(0,0.1,0),at=c(0:5),cex.axis=1,lwd=0,lwd.ticks=1)
qqline(q, distribution=qexp,col="Black", lty=1, lwd=2.5)
```



