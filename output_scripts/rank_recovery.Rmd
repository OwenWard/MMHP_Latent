---
title: "Rank Recovery"
author: "Owen G. Ward"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: FALSE
    code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(tidyverse)
library(rstan)
library(cmdstanr)
library(compete)
```



# Introduction 

We want to consider two further concepts related to the models we have built
and used as comparisons in this paper. In particular:

1. Examine the performance of the comparison models in recovering data simulated under
the (degree corrected) C-MMHP model.
1. Based on the above, and using the I&SI objective, evaluate the 
performance of models when we estimate the latent ranking on a subset of the
data, such as the first half of the events, and then infer the I and SI scores
based on those rankings for the remaining events.


# Comparison models on simulated data

We first simulate a single dense network from the C-MMHP model.

```{r load functions}
source(here("lib",'uniHawkes.R'))
source(here("lib","mmhp.R"))
source(here("lib",'simulatePrediction.R'))
source(here("lib",'plotUtil.R'))
source(here("lib",'inferLatentMmhp.R'))
source(here("lib",'drawIntensity.R'))
source(here("lib",'myGlicko.R'))
source(here("lib",'naiveRankHierarchy.R'))
source(here("lib",'expertRankHierarchy.R'))
cut_off <- 3

model1_fn <- list(alpha.fun = function(x, y, eta1, eta2, eta3){
  return(eta1 * x * y *exp(-eta2 * abs(x - y))/(1 + exp(-eta3 * (x - y) ) ) ) })

model3_fn <- list(alpha.fun = function(x, y, eta1, eta2){
  return(eta1 * x * y * exp(-eta2 * abs(x - y) ) )},
                  q1.fun = function(x, y, eta3){
                    return(exp(-eta3 * x) )},
                  q0.fun = function(x, y, eta3){
                    return(exp(-eta3* y) ) })


#### Save the simulation parameters ####

object_fn <- list(alpha.fun = function(x, y, eta1, eta2){
  return(eta1* x *y *exp(-eta2 * abs(x - y) ) )},
                  q1.fun = function(x, y, eta3){
                    return(exp(- eta3 * x) )},
                  q0.fun = function(x, y, eta3){
                    return(exp(- eta3 * y) )})

object_par <- list(sim_lambda_0 = 0.08,
                   sim_lambda_1 = 0.15,
                   sim_eta_1 = 2.5,
                   sim_eta_2 = 0.6,
                   sim_eta_3 = 5,
                   sim_beta = 1.5,
                   f_vec_1=c(0.1, 0.2, 0.4, 0.7, 0.9))

object_matrix <- list(lambda0_matrix = matrix(object_par$sim_lambda_0,
                                            nrow = length(object_par$f_vec_1),
                                            ncol = length(object_par$f_vec_1)),
                      lambda1_matrix = matrix(object_par$sim_lambda_1,
                                            nrow = length(object_par$f_vec_1),
                                            ncol = length(object_par$f_vec_1)),
                      alpha_matrix = formMatrix(function(x,y)
                        object_fn$alpha.fun(x, y,
                                            object_par$sim_eta_1, 
                                            object_par$sim_eta_2),
                        object_par$f_vec_1),
                      beta_matrix = matrix(object_par$sim_beta,
                                         nrow = length(object_par$f_vec_1),
                                         ncol = length(object_par$f_vec_1)),
                      q1_matrix = formMatrix(function(x, y) 
                        object_fn$q1.fun(x, y, object_par$sim_eta_3),
                                           object_par$f_vec_1),
                      q2_matrix = formMatrix(function(x, y) 
                        object_fn$q0.fun(x, y, object_par$sim_eta_3),
                                           object_par$f_vec_1))

```



```{r sim data from c-mmhp, cache=TRUE}
sim_model3_data <- simulateLatentMMHP(lambda0_matrix = object_matrix$lambda0_matrix,
                                      lambda1_matrix = object_matrix$lambda1_matrix,
                                      alpha_matrix = object_matrix$alpha_matrix,
                                      beta_matrix = object_matrix$beta_matrix,
                                      q1_matrix = object_matrix$q1_matrix,
                                      q2_matrix = object_matrix$q2_matrix,
                                      horizon = 200)
clean_sim_data <- cleanSimulationData(raw_data = sim_model3_data, 
                                        cut_off = cut_off, 
                                      N = length(object_par$f_vec_1))
```


```{r recover cmmhp model, cache=TRUE}
# model3 <- stan_model(here("lib","sim_model3.stan"))
model3 <- cmdstan_model(here("lib","sim_model3.stan"))
data_list <- list(max_Nm=max(clean_sim_data$N_count),
                    N_til = length(clean_sim_data$I_fit),
                    M=sum(clean_sim_data$N_count>=cut_off),
                    N=length(object_par$f_vec_1),
                    I_fit = clean_sim_data$I_fit,
                    J_fit = clean_sim_data$J_fit,
                    T = tail(clean_sim_data$day_hour,1),
                    Nm = as.vector(clean_sim_data$N_count[clean_sim_data$N_count 
                                                          >= cut_off]),
                    event_matrix = clean_sim_data$event_matrix,
                    interevent_time_matrix = clean_sim_data$time_matrix,
                    max_interevent = clean_sim_data$max_interevent)

model3_stan_fit <- model3$sample(data = data_list,
                                num_warmup = 500,
                                num_samples = 500,
                                chains = 4, 
                                parallel_chains = 4,
                                refresh = 100)

```



```{r extract stan fit}
stanfit <- rstan::read_stan_csv(model3_stan_fit$output_files())

stansims <- rstan::extract(stanfit)
## truth is .1, .2, .4, .7, .9
apply(stansims$f, 2, mean)
apply(stansims$f, 2, sd)
```


```{r fit I&SI}
count_data <- get_wl_matrix(df = cbind(clean_sim_data$start,clean_sim_data$end))
isi.out <- compete::isi98(m = count_data, random = TRUE)
isi_rank <- as.numeric(rev(isi.out$best_order)) # ranked from lowest to highest

table(1:5,isi_rank)
```