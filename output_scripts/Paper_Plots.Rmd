---
title: "Plots for Latent Hawkes Paper"
author: "Owen G. Ward"
date: '`r Sys.Date()`'
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: FALSE
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.path = "paper_figure/",
                      dev = 'png', fig.height = 4.5, fig.width = 7,
                      warning = FALSE)

slides_plots <- FALSE
extra_plots <- FALSE
current_cohort <- 5

# don't write to this path
data_path <- "../output/"

func_dir <- "../lib/"

library(here)
library(rstan)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
options(mc.cores = parallel::detectCores())
library(tidyverse)
library(R.utils)
library(RColorBrewer)
library(fields)
library(bayesplot)
library(viridis)
library(here)
library(compete)
library(colorspace)
source(paste(func_dir,'naiveRankHierarchy.R',sep = ""))
source(paste(func_dir,'expertRankHierarchy.R',sep = ""))
source(paste(func_dir,'cleanData.R',sep = "")) 
source(paste(func_dir,'prepareDataStan.R',sep = "")) 
source(paste(func_dir,'inferLatentMmhp.R',sep = ""))
source(paste(func_dir,'plotUtil.R',sep = "")) 
source(paste(func_dir,'mmhp.R',sep = ""))
source(paste(func_dir,'uniHawkes.R',sep = ""))
source(paste(func_dir,'simulatePrediction.R',sep = ""))
source(paste(func_dir,'myGlicko.R',sep = ""))
source(paste(func_dir,'matrixPlotParameter.R',sep = ""))
source(paste(func_dir,'residualStructureScore.R',sep = ""))
source(paste(func_dir,'drawIntensity.R',sep =""))
source("https://gist.githubusercontent.com/jalapic/6ca3ece44bdcdc522bb735f183aa0ca0/raw/1a07f469eff08117121b6cbebcd22fb7569e3ee8/compete_extra.R")

cohort_names <- paste("cohort",c(9,10,12,15,16,17,18,37,38,45),sep='')
cohort_short_names <- paste("C",c(9,10,12,15,16,17,18,37,38,45),sep='')
cut_off <- 3
mice_number <- 12

```



```{r load rankings,echo=FALSE,include=FALSE,results='hide',cache=TRUE}
full_data <- readRDS("../data/mice.RData")
# A=c9, B=c10, C=c12, D=c15, E=c16, F=c17, G=c18, H=c37, I=c38. J=c45

# Define the cohorts will be fitted
fit_cohorts <- c(1:10)
naive_rank_10 <- list()
expert_rank_10 <- list()
out <- captureOutput(for(curr_cohort in fit_cohorts){
  naive_rank_10[[curr_cohort]] <-
    naiveRankHierarchy(full_data[[cohort_names[curr_cohort]]])
  expert_rank_10[[curr_cohort]] <-
    expertRankHierarchy(full_data[[cohort_names[curr_cohort]]])
})


```

```{r define_functions}
model1_fn <- list(alpha.fun = function(x,y,eta1,eta2,eta3){return(eta1*x*y*exp(-eta2*abs(x-y))/(1 +
                                                        exp(-eta3*(x-y))))})

model3_fn <- list(alpha.fun = function(x,y,eta1,eta2){return(eta1*x*y*exp(-eta2*abs(x-y)))},
                  q1.fun = function(x,y,eta3){return(exp(-eta3*x))},
                  q0.fun = function(x,y,eta3){return(exp(-eta3*y))})


```


```{r creat colour df}
col_df <- tibble(method = c("I&SI", "AggRank", "DSNL", "Glicko", "I-MMHP",
            "C-HP", "C-DCHP", "True", "C-MMHP"),
            cols = viridis(9))

```

<!-- The aim of this notebook is a way to quickly and efficiently create all the plots -->
<!-- required for this paper. They will be built with the current fits and models. -->



# Figure 2: Contour Plot and C-HP Diagnostics

This is not effected by the final model.

## Figure 2a: Contour Plot

```{r fig-2a-contour-plot}
current_cohort <- 5
#png(paste(plot_path,"contour.png",sep=""),width=480,height=480)
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_hp$eta_1)
eta2_mean <- mean(sim_cohort_hp$eta_2)
eta3_mean <- mean(sim_cohort_hp$eta_3)
z.func <- function(x,y){
  return(x*y*eta1_mean*exp(-eta2_mean*abs(x-y))/(1+exp(-eta3_mean*(y-x))))
  # this is because axes are flipped that we have y-x in last term
  #return(x*y*eta1_mean/(1+exp(eta2_mean*abs(x-y)-eta3_mean*(y-x))))
}
z_plot <- outer(seq(1,0,-0.01),  
                seq(0,1,0.01), 
                z.func)
my.image.plot(seq(0,1,0.01), seq(0,1,0.01), z_plot,
              xlab=expression(f[j]),ylab=expression(f[i]),
              my.main="(a)", cex.main=2.3, 
              cex.lab=2.5, xLabels=c(1,0), yLabels=c(0,1))

```


## Fig 2b: C-HP Diagnostics

<!-- This is using the correct form of the compensator for a Hawkes process. -->


```{r fig-2b-diag-plot,echo=FALSE,warning=FALSE}
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_hp$eta_1)
eta2_mean <- mean(sim_cohort_hp$eta_2)
eta3_mean <- mean(sim_cohort_hp$eta_3)
f_est <- apply(sim_cohort_hp$f,2,mean)
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("observe.id","observe.time")])

ks.stat.matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
n_matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
Lambda_matrix <- matrix(list(),nrow=mice_number,ncol=mice_number)
for(k in 1:mice_number){
  for(l in c(1:mice_number)[-k]){
    i<-expert_rank_10[[current_cohort]][k]
    j<-expert_rank_10[[current_cohort]][l]
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0){
      param_mean <- list(lambda0=mean(sim_cohort_hp$lambda0),
                         alpha=model1_fn$alpha.fun(f_est[i],
                                                   f_est[j],
                                                   eta1_mean,
                                                   eta2_mean,
                                                   eta3_mean),
                         beta=mean(sim_cohort_hp$beta))
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_Lambda <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ ## check length > 2
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                          return_df$recipient == j &
                            return_df$observe.id==cur_win,"event.times"][[1]]
        current_obs_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                            return_df$observe.id==cur_win,"observe.time"]
        Lambda_vec <- uniHawkesCompensator(object = param_mean,
                              events = c(current_event_time,
                                         current_obs_time))
        all_Lambda <- c(all_Lambda,Lambda_vec)
        n_matrix[i,j] <- n_matrix[i,j] + length(current_event_time)
      }
      if(length(all_Lambda)>0){
        ks.stat.matrix[i,j] <-  ks.test(all_Lambda,"pexp",
                                        rate = 1/mean(all_Lambda))$statistic
        Lambda_matrix[i,j][[1]] <- all_Lambda
      }
    }
  }
}

# png(paste(plot_path,"/diagonsis_model1_",cohort_names[current_cohort],".png",sep=''),
#     width=480,height=480)
# -------------- KS plot (stat)
col.vec <- cRamp(as.vector(ks.stat.matrix))
## need to do some sort of transformation between these here
vir_cols <- viridis::viridis(length((as.vector(ks.stat.matrix))))
#order(as.vector(ks.stat.matrix),method = "")

values <- as.vector(ks.stat.matrix)
sorted_vals <- sort(ks.stat.matrix)
#match(values,sorted_vals)
col.vec.vir <- vir_cols[match(values,sorted_vals)]

####
par(oma = c(6,4,4,1), mar=rep(0,4),
    mgp = c(0, .2, 0))
layout(cbind(matrix(data=c(1:(12*12)), nrow = 12, ncol = 12, 
                    byrow = TRUE),rep(12*12+1,12)), 
       widths=c(rep(1,12),2), heights=rep(1,12))
for(i in expert_rank_10[[current_cohort]]){
  for(j in expert_rank_10[[current_cohort]]){
    if(ks.stat.matrix[i,j]==0){
      plot(0,0,xlim=c(0,5),ylim=c(0,5),type="n", xlab="", ylab="", 
           axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4],
           border = 0, col = 'white')
    }else{
      Lambda.test <- Lambda_matrix[i,j][[1]]
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4], 
           border = 0, col = col.vec.vir[matrixToVecIdx(i,j,mice_number)])
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE,add=TRUE, lwd=2)
      plot(ecdf(Lambda.test), add = TRUE, do.points = FALSE,
           verticals = TRUE, col = "red", lwd = 2)
    }
  }
}
par(mar = c(0,2,0,3),mgp=c(0,0.8,0))
m1_ks <- ks.stat.matrix
col_obj <- list(x.vec = seq(0,max(as.vector(ks.stat.matrix)),length.out = 100),
                col.vec = viridis(100))

temp <- cLegend(as.vector(ks.stat.matrix))
#which(temp$x.vec == as.vector(ks.stat.matrix))
## need to adjust this for the legend also.
# image(1, cLegend(as.vector(ks.stat.matrix))$x.vec,
#       matrix(data=cLegend(as.vector(ks.stat.matrix))$x.vec, 
#              ncol=length(cLegend(as.vector(ks.stat.matrix))$x.vec),nrow=1),
#       col=cLegend(as.vector(ks.stat.matrix))$col.vec,
#       xlab="",ylab="",axes=FALSE)
image(1, col_obj$x.vec,
      matrix(data=col_obj$x.vec, 
             ncol=length(col_obj$x.vec),nrow=1),
      col=col_obj$col.vec,
      xlab="",ylab="", axes = FALSE)
axis(4, at=c(0,0.3,0.6), labels=c(0,0.3,0.6), las= HORIZONTAL<-1,
     cex.axis=2.4)

mtext(text=expert_rank_10[[current_cohort]],
      side = 1, line = 1.8, outer = TRUE, cex = 1.8,
      at=1/14*c(1:12)-1/22)
mtext(text = expert_rank_10[[current_cohort]],
      side = 2, line = 0.5, outer = TRUE, cex = 1.8,
      at =1/12*c(12:1)-1/20, las = 2)
mtext(text = "(b)", side = 3, line = 1.4, outer = TRUE,
      cex = 2.2,
      at=0.45, font=2)
#dev.off()
```

# Figure 3: Comparison of C-HP and C-DCHP

## Figure 3a: Baseline rates


```{r fig-3a-baseline-rate}
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
gamma_mean <- apply(sim_cohort_dchp$gamma,2,mean)
zeta_mean <- apply(sim_cohort_dchp$zeta,2,mean)

# social matrix plot
latent_social_matrix <- gamma_mean %*%
  t(rep(1,mice_number)) + rep(1,mice_number) %*% t(zeta_mean)

# png(paste(plot_path,"/lambda0_",
# cohort_names[current_cohort],".png",sep=''),
#     width=400, height=300)
matrixPlotParameter(latent_social_matrix[
  rev(expert_rank_10[[current_cohort]]),
                                         expert_rank_10[[current_cohort]]],
                    xLabels=expert_rank_10[[current_cohort]],
                    yLabels=rev(expert_rank_10[[current_cohort]]) )
                    # title = "(a)" )
# mtext(text=c(1,2,11,6,7,9), side=1, line=-0.35, outer=TRUE, cex=1.3,
#       at=1/17.8*seq(2,12,2)+0.09)
#dev.off()
```
## Figure 3b: Ranking Comparison

```{r fig-3b-rank-comparison, include=FALSE,eval=FALSE}
# current_cohort <- 5



colors_plot <- col_df %>% filter(method %in% c("C-HP","C-DCHP")) %>%
  pull(cols) 
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
# png(paste(plot_path,"/rank_",cohort_names[current_cohort],".png",sep=''),
#     width=400, height=300)
par(oma = c(0,0,2,0), mar = c(3,4,1,1),mgp=c(0,0.5,0))
plot(order(expert_rank_10[[current_cohort]]),
     apply(sim_cohort_hp$f,2,mean),pch=16,cex=1.2,
     #col= "steelblue",
     col = colors_plot[1],
     ylab="",xlab="",
     xlim=c(1,12.5),ylim=c(0,1), xaxt="n", yaxt="n")
segments(order(expert_rank_10[[current_cohort]]),
         apply(sim_cohort_hp$f,2,mean)-apply(sim_cohort_hp$f,2,sd),
         order(expert_rank_10[[current_cohort]]),
         apply(sim_cohort_hp$f,2,mean)+apply(sim_cohort_hp$f,2,sd),
         #col= add.alpha("steelblue",0.8),lwd=2)
         col = add.alpha(colors_plot[1],0.8), lwd =2)
points(order(expert_rank_10[[current_cohort]])+0.2,
       apply(sim_cohort_dchp$f,2,mean),
       pch=16,cex=1.2,
       col=colors_plot[2])
       #col="goldenrod2")
segments(order(expert_rank_10[[current_cohort]])+0.2,
         apply(sim_cohort_dchp$f,2,mean)-apply(sim_cohort_dchp$f,2,sd),
         order(expert_rank_10[[current_cohort]])+0.2,
         apply(sim_cohort_dchp$f,2,mean)+apply(sim_cohort_dchp$f,2,sd),
         col= add.alpha(colors_plot[2],0.8),lwd=2)
         #col= add.alpha("goldenrod2",0.8),lwd=2)

axis(BELOW<-1, at=1:12, labels=expert_rank_10[[current_cohort]], cex.axis=1.3, tck=-0.015)
#mtext(text=11, side=1, line=0.5, cex=1.3, at=6)

axis(LEFT <-2, at=seq(0,1,0.2), labels=seq(0,1,0.2), las= HORIZONTAL<-1,
     cex.axis=1.3, tck=-0.015)
mtext(side=1, text="I&SI rank", line=1.8, cex=1.5)
mtext(side=2, text="Latent rank", line=2.4, cex=1.6)
mtext(side=3, text="(b)", line=0.8, cex=1.6, font=2)
legend('bottomleft', legend = c("C-HP", "C-DCHP"),
       pch = c(16, 16), lty = c(1, 1), lwd=c(2,2),
       #col=c("steelblue","goldenrod"),
       col=c(colors_plot[1],colors_plot[2]),
       cex=1.5)
#dev.off()
```


```{r, eval=FALSE, include=FALSE}
par(mar=c(3,3,1,1))
plot(as.vector(n_matrix[n_matrix>0]), as.vector(ks.stat.matrix[n_matrix>0]),
     xlab="", ylab="", pch=16, col="gray", cex= 0.8, xaxt="n", yaxt="n",
     ylim=c(0,0.65))
mtext("Number of events", cex=1.5, side=1, line=1.8)
mtext("K-S statistics", cex=1.5, side=2, line=1.5)
mgp.axis(1,mgp=c(0,0.3,0),at=seq(0,120,10),cex.axis=1,lwd=0,lwd.ticks=0.1)
mgp.axis(2,mgp=c(0,0.1,0),at=seq(-0.2,0.6,0.2),cex.axis=1,lwd=0,lwd.ticks=0.8)
```




# Figure 4:

## Figure 4a Recover Latent Ranks
```{r fig-4a, fig.height=3.5,fig.width=8}
sim_data_path <- "../output/sims_m3_update/"

# load(paste(sim_data_path,"sim_model3_fit123.RData",sep=''))
# load(paste(sim_data_path,"fit123_state_est.RData",sep=''))
#### need to edit here to account for separate files now

m3_files <- list.files(sim_data_path, pattern = "sim_model3_fit*")
#m1_files

# load(paste0(m1_path,m1_files[1]))
sim_model3_stan_sim1_total <- list()
sim_model3_stan_sim2_total <- list()
sim_model3_stan_sim3_total <- list()

for(i in seq_along(m3_files)) {
  load(paste0(sim_data_path,m3_files[i]))
  sim_model3_stan_sim1_total[[i]] <- sim_model3_stan_sim1
  sim_model3_stan_sim2_total[[i]] <- sim_model3_stan_sim2
  sim_model3_stan_sim3_total[[i]] <- sim_model3_stan_sim3
  
}


n_sim <- 50

#png(paste(plot_path,"sim_latent_recover.png",sep=""), height=500, width=900)
par(mfrow=c(3, length(object_par$f_vec_1)),
    mar=c(0,0,1,0),
    oma=c(6.5,11,3.5,1))

y.ub <- c(12,12,12,12,12)
text.y <- c(rep(8,4),8)
text.x <- c(0.1,0.2,0.4,0.7,0.9)
text.x.adj <- c(0.3,0.4,0.6,0.5,0.8)

model_colors <- col_df %>% filter(method %in% c("C-HP",
                                                "C-DCHP", "C-MMHP")) %>%
  pull(cols)

for(m in c(1:3)){
  for(j in c(1:length(object_par$f_vec_1))){
    plot(1,4,xlim=c(0,1),ylim=c(0,y.ub[j]),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    
    ## Posterior density
    # current_result <- eval(parse(text=paste("sim_model3_stan_sim",m,sep="")))
    current_result <- eval(parse(text=paste("sim_model3_stan_sim",
                                            m,
                                            "_total",
                                            sep="")))
    for(i in c(1:n_sim)){
      lines(density(current_result[[i]]$f[,j]),
            col=add.alpha(model_colors[m], alpha=0.8),cex=0.6,lwd=0.8)
    }
    
    ## plot true value
    abline(v=object_par$f_vec_1[j],lwd=1.8,lty=2,col="gray30")
    
    ## plot box
    box.wdt <- 1.5
    box.col <- "black"
    box(lty = 'solid',col=box.col,lwd=0.7)
    
    if(m==3){
      text(text.x.adj[j],text.y[j],text.x[j],cex=2.4)
    }
  }
  ## bottom
  mtext(text = expression(f[1],f[2],f[3],f[4],f[5]), 
        side = 1, line = 2.4, outer = TRUE, 
        at = c(1:length(object_par$f_vec_1))/length(object_par$f_vec_1)-0.1,
        cex = 2)
  mtext(text = "Latent rank variables", side = 1,
        line = 5.3,
        outer = TRUE,
        cex = 2.25,
        at = 0.5)
  ## top
  mtext(text = "(a)", side = 3,
        line = 0, 
        outer = TRUE,
        cex = 2.5,
        at = 0.5, font = 2)
  ## left
  mtext(text=rev(c("C-HP  ","C-DCHP","C-MMHP")), side=2, line=0.5, outer=TRUE, 
        at=c(0:2)/3+0.15,
        cex=1.75, las=2)
}

```
```{r fig4a-new-hist, fig.height=3.5,fig.width=8}
model_colors <- col_df %>% filter(method %in% c("C-HP",
                                                "C-DCHP",
                                                "C-MMHP"))

model_colors <- model_colors %>% pull(cols)


m1 <- sim_model3_stan_sim1_total %>%
  map( ~apply(.x$f, 2, mean)  ) %>%
  enframe() %>%
  unnest(cols = value) %>%
  mutate(node_id = rep(c("f1","f2","f3","f4","f5"), 50),
         method = "C-HP")

m2 <- sim_model3_stan_sim2_total %>%
  map( ~apply(.x$f, 2, mean)  ) %>%
  enframe() %>%
  unnest(cols = value) %>%
  mutate(node_id = rep(c("f1","f2","f3","f4","f5"), 50),
         method = "C-DCHP")

m3 <- sim_model3_stan_sim3_total %>%
  map( ~apply(.x$f, 2, mean)  ) %>%
  enframe() %>%
  unnest(cols = value) %>%
  mutate(node_id = rep(c("f1","f2","f3","f4","f5"), 50),
         method = "C-MMHP")

rank_means <- bind_rows(m1,m2,m3)

# rank_means

true_values <- tibble(
  id = c("f1", "f2","f3","f4","f5"),
  values = c(0.1,0.2,0.4,0.7,0.9),
  val_names = c("   0.1","0.2","0.4","0.7","0.9")
)


rank_means %>% 
  left_join(true_values, by = c("node_id" = "id")) %>%
  ggplot(aes(value, fill = method)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = values), alpha = 0.6,
             linetype = "dashed") +
  ### add text here
  geom_text(aes(values, 18, label = val_names),
            size = 3, hjust = 1) +
  scale_fill_manual(values = model_colors) +
  facet_grid(cols = vars(node_id), rows = vars(method)) + 
  theme_bw() + theme(
    plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
    text = element_text(size = 12),
    axis.text.x=element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "") 


```


## Figure 4b: Recover Latent States


```{r prepare data for 4b,cache=TRUE}
plot.s <- 7#7 is pretty good
plot.i <- 4
plot.j <- 5

cur_i <- 4
cur_j <- 5



load(paste0(sim_data_path,"/" ,"sim_model3_",
                               plot.s,
                              ".RData"))
test.mmhp <- sim_model3_data$mmhp_matrix[plot.i,plot.j][[1]]
temp.t <- test.mmhp$tau
current.n <- length(temp.t)-1
time.segment <- seq(0, tail(temp.t,1), length.out = 5000)

### Preprocess the model inference result
## model 1
#########
model1_par_est <- list(lambda0 = mean(sim_model3_stan_sim1_total[[plot.s]]$lambda0),
                       eta_1 =
                         mean(sim_model3_stan_sim1_total[[plot.s]]$eta_1),
                       eta_2 =
                         mean(sim_model3_stan_sim1_total[[plot.s]]$eta_2),
                       eta_3 =
                         mean(sim_model3_stan_sim1_total[[plot.s]]$eta_3),
                       beta = mean(sim_model3_stan_sim1_total[[plot.s]]$beta),
                       f = apply(sim_model3_stan_sim1_total[[plot.s]]$f, 2, mean))
lambda.m1<-uniHawkesIntensityNumeric(object = list(lambda0 = 
                                                   model1_par_est$lambda0,
                                    alpha =
                                      model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                    model1_par_est$f[plot.j],
                                    model1_par_est$eta_1,
                                    model1_par_est$eta_2,
                                    model1_par_est$eta_3),
                                    beta = model1_par_est$beta),
                                     events = temp.t,
                                     time.vec = time.segment)


## model2
#############
model2_par_est <- list(gamma = apply(sim_model3_stan_sim2_total[[plot.s]]$gamma,
                                     2, mean),
                    zeta = apply(sim_model3_stan_sim2_total[[plot.s]]$zeta, 2, mean),
                    eta_1 = mean(sim_model3_stan_sim2_total[[plot.s]]$eta_1),
                    eta_2 = mean(sim_model3_stan_sim2_total[[plot.s]]$eta_2),
                    eta_3 = mean(sim_model3_stan_sim2_total[[plot.s]]$eta_3),
                    beta = mean(sim_model3_stan_sim2_total[[plot.s]]$beta),
                    f = apply(sim_model3_stan_sim2_total[[plot.s]]$f, 2, mean))

lambda.m2 <- uniHawkesIntensityNumeric(object=list(
  lambda0 = model2_par_est$gamma[plot.i]+
          model2_par_est$zeta[plot.j],                                        
  alpha = model1_fn$alpha.fun(model2_par_est$f[plot.i],
                            model2_par_est$f[plot.j],
                            model2_par_est$eta_1,
                            model2_par_est$eta_2,
                            model2_par_est$eta_3),
                beta = model2_par_est$beta),
                events = temp.t,
                time.vec = time.segment)

## Model3
###
lam0_vec <- apply(sim_model3_stan_sim3_total[[plot.s]]$lambda0, 2, mean)
lam1_vec <- apply(sim_model3_stan_sim3_total[[plot.s]]$lambda1, 2, mean)
lam0_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                       ncol = length(object_par$f_vec_1))
lam1_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                       ncol = length(object_par$f_vec_1))

clean_sim_data <- cleanSimulationData(raw_data = sim_model3_data, 
                                      cut_off = cut_off,
                                      N = length(object_par$f_vec_1))

for(i in seq_along(lam0_vec)) {
  row_id <- clean_sim_data$I_fit[i]
  col_id <- clean_sim_data$J_fit[i]
  lam0_par_est[row_id, col_id] <- lam0_vec[i]
  lam1_par_est[row_id, col_id] <- lam1_vec[i]
}


###

#############
mmhp_par_est <- list(lambda0 = lam0_par_est,
                     lambda1 = lam1_par_est,
                     eta_1 = mean(sim_model3_stan_sim3_total[[plot.s]]$eta_1),
                     eta_2 = mean(sim_model3_stan_sim3_total[[plot.s]]$eta_2),
                     eta_3 = mean(sim_model3_stan_sim3_total[[plot.s]]$eta_3),
                     beta = mean(sim_model3_stan_sim3_total[[plot.s]]$beta),
                     f = apply(sim_model3_stan_sim3_total[[plot.s]]$f,2,mean))

object_hat <- list(lambda0 = mmhp_par_est$lambda0[cur_i, cur_j],
                   lambda1 = mmhp_par_est$lambda1[cur_i, cur_j],
                   alpha = model3_fn$alpha.fun(mmhp_par_est$f[cur_i],
                                             mmhp_par_est$f[cur_j],
                                             mmhp_par_est$eta_1,
                                             mmhp_par_est$eta_2),
                   beta = mmhp_par_est$beta,
                   q1 = model3_fn$q1.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3),
                   q2=model3_fn$q0.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3))

## then need to load in the state estimate here
load(paste0(sim_data_path,"/", "fit123_state_est_", plot.s, ".RData"))


state.est.latent.mmhp <- interpolate_state_est_lst[plot.i,plot.j][[1]]
state.est.latent.mmhp.new <- fixInterpolateState(state.est.latent.mmhp,
                                                 termination=200)

step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,
                        2 - state.est.latent.mmhp$z.hat)

lambda.m3 <- mmhpIntensityNumeric(params = object_hat,
                                  t = temp.t[-1],
                                  time.vec = time.segment,
                                  latent.vec = step.fun.est(time.segment))

object_true <- lapply(object_matrix,function(x) x[plot.i,plot.j])
names(object_true) <- c("lambda0","lambda1","alpha","beta","q1","q2")

lambda.true <- mmhpTrueIntensityNumeric(params = object_true,
                                        t = temp.t,
                       latent = list(x = fixStateTransition(test.mmhp)$x,
                                     z = fixStateTransition(test.mmhp)$z),
                                     time.vec = time.segment)

```


```{r fig-4b-recover-latent-states,fig.width=8,fig.height=4}
y.ub <- c(35,35,35)#c(130,72,31)
x_events <- 190#135#150
layout(matrix(c(1:6), 6, 1), heights=rep(c(7.5,1),3))
my.xlim <- 200#160#200#130
my.long.x <- 205#205#134.5
legend.x <- c(60,60,60)#c(135,135,135)
legend.y <- #c(34,32,32)
legend.y <- c(23,23,23)#c(15,12,15)#c(62,37,18)#c(22,22,22)
legend.cex <- 1.5 #3
line.alpha <- c(0.9,0.6)
line.wdth <- c(2,2.5)
negative.col <- add.alpha('lightskyblue')
positive.col <- add.alpha('tomato')
#negative.col <- viridis::viridis(5,alpha = 0.6)[1]
#positive.col <- viridis::viridis(5,alpha = 0.6)[4]
par(mar = c(0,0.3,0,0.1), oma = c(3,3.5,4,0),
    tcl=0.2,mgp=c(0.5,0,0), xpd=TRUE)

# model1
############
true.object <- object_true

drawUniMMHPIntensityPaper(true.object,
                          simulation = fixStateTransition(test.mmhp),
                          yupper=y.ub[1], 
                          color=add.alpha("black", alpha=line.alpha[1]),
                          line.width=line.wdth[1],
                          y.ratio=-0.05, min.y=-2,
                          min.x=0, max.x=my.xlim,
                          title_name=paste(plot.i,"->",plot.j),
                          title.cex = 2,
                          box.type="n")
drawHawkesIntensityPaper(lambda0=model1_par_est$lambda0,
                         alpha=model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                                   model1_par_est$f[plot.j],
                                                   model1_par_est$eta_1,
                                                   model1_par_est$eta_2,
                                                   model1_par_est$eta_3),
                         beta=model1_par_est$beta,
                         events=test.mmhp$tau,
                         color=add.alpha(model_colors[1],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])

## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)


## add legend
# changed 34 to 23, 25 to 18, -20 to -10
# legend(10,legend.y[1],c("State 1/0 events","State change point"),
#        col = c(NA,"red"),
#        y.intersp=0.85,x.intersp=-0.1, bty = "n",
#        pch = c(NA,4), pt.cex = c(NA,2), cex=legend.cex,
#        lty = c(NA,NA), lwd=c(NA,4))
# points(29,84,pch=1,cex=2,col="blue")
# points(26,84,pch=16,cex=2,col="blue")
legend(legend.x[1],legend.y[1],c("True"),
       col = c("black"),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)
legend(legend.x[1]+22,legend.y[1],c("C-HP"),
       col = c(model_colors[1]),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-4,4), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m1$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now ###
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.positive,0),col=positive.col,border=NA)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model2
############
drawUniMMHPIntensityPaper(true.object,simulation=fixStateTransition(test.mmhp),
                          yupper=y.ub[2], 
                          color=add.alpha("black", alpha=line.alpha[1]),
                          line.width=line.wdth[1],
                          y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim, 
                          box.type="n")
drawHawkesIntensityPaper(lambda0=model2_par_est$gamma[plot.i]+
                           model2_par_est$zeta[plot.j],
                         alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                                                   model2_par_est$f[plot.j],
                                                   model2_par_est$eta_1,
                                                   model2_par_est$eta_2,
                                                   model2_par_est$eta_3),
                         beta=model2_par_est$beta,
                         events=test.mmhp$tau,
                         color=add.alpha(model_colors[2],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])
legend(legend.x[2],legend.y[2],"C-DCHP",
       col = model_colors[2],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty = 1, lwd = 5, cex= legend.cex,seg.len=1)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(legend.x[2]-50,
       legend.y[2]+2,c("State 0/1 events","State change point"),
       col = c(NA,"red"),
       y.intersp=0.85,x.intersp=-0.5, bty = "n",
       pch = c(NA,4), pt.cex = c(NA,2), cex=legend.cex,
       lty = c(NA,NA), lwd=c(NA,2))
points(legend.x[2]-46,legend.y[2] - 4.5, pch = 1, cex = 2, col = "blue")
points(legend.x[2]-44,legend.y[2] - 4.5, pch = 16, cex = 2, col = "blue")

## delta lambda
par(mar = c(0,0.3,0,0.1))
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t

plot(lambda.true$time.vec,delta.lambda,xlim=c(0,my.xlim), 
     ylim=c(-4,4), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model3
########
par(mar = c(0,0.3,1,0.1))
drawUniMMHPIntensityPaper(true.object,
                          simulation=fixStateTransition(test.mmhp),
                          yupper=y.ub[3],
                          color=add.alpha("black", alpha=line.alpha[1]),
                          line.width=line.wdth[1],
                          y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim, 
                          box.type="n")
drawUniMMHPIntensityPaper(object_hat,
                          simulation = list(
                            x=state.est.latent.mmhp.new$x.hat,                                          
                            z=state.est.latent.mmhp.new$z.hat,
                            tau=test.mmhp$tau,zt=test.mmhp$zt,
                            lambda.max=test.mmhp$lambda.max),
                          yupper=y.ub,add=TRUE,
                          color=add.alpha(model_colors[3],
                                          alpha=line.alpha[2]),
                          line.width=line.wdth[2])
legend(legend.x[3],legend.y[3],"C-MMHP",
       col = model_colors[3],
       y.intersp=0.6,x.intersp=0.1,bty = "n",
       lty =1, lwd = 5,cex=legend.cex,seg.len=1)
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(legend.x[3]-50,legend.y[3]+2, c("Overestimation","Underestimation"),
       col = c(positive.col,negative.col),
       y.intersp=0.75,x.intersp=0.5,bty = "n",
       lty = c(1,1), lwd = c(10,10), cex=legend.cex,seg.len=0.8)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-4,4), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m3-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


## top
mtext(text="(b)",side=3,line=0.8,outer=TRUE,cex=2.5,font=2)
## bottom
mtext(text="Time",side=1,line=2,outer=TRUE,cex=2.25)
## left
mtext(text="Intensity",side=2,line=0.6,outer=TRUE,cex=2.25)


```

## Fig 4 repeated for data generated from other models

For completeness, we also wish to repeat the above two plots using data generated 
from M1 and M2.

For data simulated from M1.

```{r est ranks for m1 sim data, include=extra_plots, eval=extra_plots}
m1_path <- "../output/sims/M1/"

m1_files <- list.files(m1_path, pattern = "sim_model1_fit*")
#m1_files

# load(paste0(m1_path,m1_files[1]))
sim_model1_stan_sim1_total <- list()
sim_model1_stan_sim2_total <- list()
sim_model1_stan_sim3_total <- list()

for(i in seq_along(m1_files)) {
  load(paste0(m1_path,m1_files[i]))
  sim_model1_stan_sim1_total[[i]] <- sim_model1_stan_sim1
  sim_model1_stan_sim2_total[[i]] <- sim_model1_stan_sim2
  sim_model1_stan_sim3_total[[i]] <- sim_model1_stan_sim3
  
}

m2_path <- "../output/sims/M2/"

m2_files <- list.files(m2_path, pattern = "sim_model2_fit*")
#m1_files

# load(paste0(m1_path,m1_files[1]))
sim_model2_stan_sim1_total <- list()
sim_model2_stan_sim2_total <- list()
sim_model2_stan_sim3_total <- list()

for(i in seq_along(m2_files)) {
  load(paste0(m2_path,m2_files[i]))
  sim_model2_stan_sim1_total[[i]] <- sim_model2_stan_sim1
  sim_model2_stan_sim2_total[[i]] <- sim_model2_stan_sim2
  sim_model2_stan_sim3_total[[i]] <- sim_model2_stan_sim3
  
}

```


```{r plot est ranks M1 and M2, include=extra_plots, eval=extra_plots}
n_sim <- 50

#png(paste(plot_path,"sim_latent_recover.png",sep=""), height=500, width=900)
par(mfrow=c(3, length(object_par$f_vec_1)),
    mar=c(0,0,1,0),
    oma=c(6.5,11,3.5,1))

y.ub <- c(12,12,12,12,12)
text.y <- c(rep(8,4),8)
text.x <- c(0.1,0.2,0.4,0.7,0.9)
text.x.adj <- c(0.3,0.4,0.6,0.5,0.8)
model_colors <- c("steelblue", "goldenrod2", "firebrick2")
model_colors <- viridis::viridis(3)

for(m in c(1:3)){
  for(j in c(1:length(object_par$f_vec_1))){
    plot(1,4,xlim=c(0,1),ylim=c(0,y.ub[j]),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    
    ## Posterior density
    current_result <- eval(parse(text=paste("sim_model1_stan_sim",
                                            m,
                                            "_total",
                                            sep="")))
    for(i in c(1:n_sim)){
      lines(density(current_result[[i]]$f[,j]),
            col=add.alpha(model_colors[m], alpha=0.8),cex=0.6,lwd=0.8)
    }
    
    ## plot true value
    abline(v=object_par$f_vec_1[j],lwd=1.8,lty=2,col="gray30")
    
    ## plot box
    box.wdt <- 1.5
    box.col <- "black"
    box(lty = 'solid',col=box.col,lwd=0.7)
    
    if(m==3){
      text(text.x.adj[j],text.y[j],text.x[j],cex=2.4)
    }
  }
  ## bottom
  mtext(text=expression(f[1],f[2],f[3],f[4],f[5]), side=1, line=2.4, outer=TRUE, 
        at=c(1:length(object_par$f_vec_1))/length(object_par$f_vec_1)-0.1,
        cex=2.4)
  mtext(text="Latent rank variables", side=1, line=5.3, outer=TRUE, cex=2.7,
        at=0.5)
  ## top
  mtext(text="Simulated from M1", side=3, line=0, outer=TRUE, cex=3,
        at=0.5, font=2)
  ## left
  mtext(text=rev(c("C-HP  ","C-DCHP","C-MMHP")), side=2, line=0.5, outer=TRUE, 
        at=c(0:2)/3+0.15,
        cex=2, las=2)
}


for(m in c(1:3)){
  for(j in c(1:length(object_par$f_vec_1))){
    plot(1,4,xlim=c(0,1),ylim=c(0,y.ub[j]),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    
    ## Posterior density
    current_result <- eval(parse(text=paste("sim_model2_stan_sim",
                                            m,
                                            "_total",
                                            sep="")))
    for(i in c(1:n_sim)){
      lines(density(current_result[[i]]$f[,j]),
            col=add.alpha(model_colors[m], alpha=0.8),cex=0.6,lwd=0.8)
    }
    
    ## plot true value
    abline(v=object_par$f_vec_1[j],lwd=1.8,lty=2,col="gray30")
    
    ## plot box
    box.wdt <- 1.5
    box.col <- "black"
    box(lty = 'solid',col=box.col,lwd=0.7)
    
    if(m==3){
      text(text.x.adj[j],text.y[j],text.x[j],cex=2.4)
    }
  }
  ## bottom
  mtext(text=expression(f[1],f[2],f[3],f[4],f[5]), side=1, line=2.4, outer=TRUE, 
        at=c(1:length(object_par$f_vec_1))/length(object_par$f_vec_1)-0.1,
        cex=2.4)
  mtext(text="Latent rank variables", side=1, line=5.3, outer=TRUE, cex=2.7,
        at=0.5)
  ## top
  mtext(text="Simulated from M2", side=3, line=0, outer=TRUE, cex=3,
        at=0.5, font=2)
  ## left
  mtext(text=rev(c("C-HP  ","C-DCHP","C-MMHP")), side=2, line=0.5, outer=TRUE, 
        at=c(0:2)/3+0.15,
        cex=2, las=2)
}
```

Similarly, we can then repeat this for Fig 4b also for both simulated 
data examples, with slightly more difficulty.

```{r process m1 for fig4b, include=extra_plots, eval=extra_plots}
plot.s <- 1#7#9
plot.i <- 4
plot.j <- 5

cur_i <- plot.i
cur_j <- plot.j

load(paste0(m1_path,m1_files[plot.s]))
clean_sim_data_m1 <- cleanSimulationData(raw_data = sim_model1_data[[1]], 
                                      cut_off = cut_off,
                                      N = length(object_par$f_vec_1))
# this loads in sim data too

temp.t <- sim_model1_data[[1]]$day_hour[ which(sim_model1_data[[1]]$start == cur_i & 
                  sim_model1_data[[1]]$end == cur_j)]
# temp.t <- test.mmhp$tau
current.n <- length(temp.t)-1
time.segment <- seq(0,tail(temp.t,1),length.out=5000)

### Preprocess the model inference result
## model 1
#########
model1_par_est <- list(lambda0 = 
                         mean(sim_model1_stan_sim1_total[[plot.s]]$lambda0),
                   eta_1 = mean(sim_model1_stan_sim1_total[[plot.s]]$eta_1),
                   eta_2 = mean(sim_model1_stan_sim1_total[[plot.s]]$eta_2),
                   eta_3 = mean(sim_model1_stan_sim1_total[[plot.s]]$eta_3),
                   beta = mean(sim_model1_stan_sim1_total[[plot.s]]$beta),
                   f = apply(sim_model1_stan_sim1_total[[plot.s]]$f,2,mean))
lambda.m1<-uniHawkesIntensityNumeric(object=list(lambda0 = 
                                                   model1_par_est$lambda0,
                                    alpha =
                                    model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                    model1_par_est$f[plot.j],
                                    model1_par_est$eta_1,
                                    model1_par_est$eta_2,
                                    model1_par_est$eta_3),
                                    beta=model1_par_est$beta),
                                    events=temp.t,
                                    time.vec=time.segment)


## model2
#############
model2_par_est <- list(gamma = apply(sim_model1_stan_sim2_total[[plot.s]]$gamma,
                                   2,mean),
                       zeta = apply(sim_model1_stan_sim2_total[[plot.s]]$zeta,
                                  2, mean),
                     eta_1 = mean(sim_model1_stan_sim2_total[[plot.s]]$eta_1),
                     eta_2 = mean(sim_model1_stan_sim2_total[[plot.s]]$eta_2),
                     eta_3 = mean(sim_model1_stan_sim2_total[[plot.s]]$eta_3),
                     beta = mean(sim_model1_stan_sim2_total[[plot.s]]$beta),
                     f = apply(sim_model1_stan_sim2_total[[plot.s]]$f, 
                             2, mean))

lambda.m2 <- uniHawkesIntensityNumeric(object=list(
  lambda0=model2_par_est$gamma[plot.i]+
          model2_par_est$zeta[plot.j],                                        
  alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                            model2_par_est$f[plot.j],
                            model2_par_est$eta_1,
                            model2_par_est$eta_2,
                            model2_par_est$eta_3),
                beta=model2_par_est$beta),
                events=temp.t,
                time.vec=time.segment)

## Model3
#############
####
lam0_vec <- apply(sim_model1_stan_sim3_total[[plot.s]]$lambda0, 2, mean)
lam1_vec <- apply(sim_model1_stan_sim3_total[[plot.s]]$lambda1, 2, mean)
lam0_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                       ncol = length(object_par$f_vec_1))
lam1_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                       ncol = length(object_par$f_vec_1))

### loaded in sim data again above

for(i in seq_along(lam0_vec)) {
  row_id <- clean_sim_data_m1$I_fit[i]
  col_id <- clean_sim_data_m1$J_fit[i]
  lam0_par_est[row_id, col_id] <- lam0_vec[i]
  lam1_par_est[row_id, col_id] <- lam1_vec[i]
}
####
mmhp_par_est <- list(lambda0 = lam0_par_est,
                     lambda1 = lam1_par_est,
                     eta_1 = mean(sim_model1_stan_sim3_total[[plot.s]]$eta_1),
                     eta_2 = mean(sim_model1_stan_sim3_total[[plot.s]]$eta_2),
                     eta_3 = mean(sim_model1_stan_sim3_total[[plot.s]]$eta_3),
                     beta = mean(sim_model1_stan_sim3_total[[plot.s]]$beta),
                     f = apply(sim_model1_stan_sim3_total[[plot.s]]$f, 2, mean))

object_hat <- list(lambda0 = mmhp_par_est$lambda0[cur_i, cur_j],
                   lambda1 = mmhp_par_est$lambda1[cur_i, cur_j],
                   alpha = model3_fn$alpha.fun(mmhp_par_est$f[cur_i],
                                             mmhp_par_est$f[cur_j],
                                             mmhp_par_est$eta_1,
                                             mmhp_par_est$eta_2),
                   beta = mmhp_par_est$beta,
                   q1 = model3_fn$q1.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3),
                   q2 = model3_fn$q0.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3))


state_est_fits <- list.files(m1_path, pattern = "fit123_state_est_M1*")
load(paste0(m1_path,state_est_fits[plot.s]))

state.est.latent.mmhp <- interpolate_state_est_lst[plot.i,plot.j][[1]]
state.est.latent.mmhp.new <- fixInterpolateState(state.est.latent.mmhp,
                                                 termination = 200)

step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,
                        2-state.est.latent.mmhp$z.hat)

lambda.m3 <- mmhpIntensityNumeric(params=object_hat,
                                  t=temp.t,
                                  time.vec=time.segment,
                                  latent.vec=step.fun.est(time.segment))

object_true <- lapply(object_matrix,function(x) x[plot.i,plot.j])
names(object_true) <- c("lambda0","lambda1","alpha","beta")


lambda.true <- uniHawkesIntensityNumeric(object = object_true,
                                        events =temp.t,
                                        time.vec = time.segment)
```


```{r fig 4b M1 sim, include=extra_plots, eval=extra_plots}
source(here("lib","mod_drawHawkesIntensityPaper.R"))
y.ub <- c(27,27,27)#c(130,72,31)
x_events <- 135#150
#model_colors <- c("steelblue", "goldenrod2", "firebrick2")
model_colors <- viridis::viridis(3)
layout(matrix(c(1:6), 6, 1), heights=rep(c(2.5,1),3))
layout(matrix(c(1:6), 6, 1), heights=rep(c(7.5,1),3))
my.xlim <- 140#160#200#130
my.long.x <- 140#205#134.5
legend.x <- c(110,110,110)#c(135,135,135)
legend.y <- #c(34,32,32)
legend.y <- c(20,20,20)#c(62,37,18)#c(22,22,22)
legend.cex <- 1.5 #3
line.alpha <- c(0.9,0.6)
line.wdth <- c(2,2.5)
negative.col <- add.alpha('lightskyblue',0.6)
positive.col <- add.alpha('tomato',0.6)
#negative.col <- viridis::viridis(5,alpha = 0.6)[1]
#positive.col <- viridis::viridis(5,alpha = 0.6)[4]
par(mar = c(0,0.3,0,0.1), oma = c(3,3.5,4,0),
    tcl=0.2,mgp=c(0.5,0,0), xpd=TRUE)

# model1
############
true.object <- object_true
# lambda.true$lambda.t <- lambda.est
# lambda.true$time.vec <- lambda.m1$time.vec

mod_drawHawkesIntensityPaper(lambda0 = true.object$lambda0,
                             alpha = true.object$alpha,
                             beta = true.object$beta,
                             events = temp.t,
                             add = FALSE,
                            yupper=y.ub[1],
                            color=add.alpha("black", alpha=line.alpha[1]),
                            line.width=line.wdth[1],
                            y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                            title_name=paste(plot.i,"->",plot.j),
                            title.cex = 2,
                            box.type="n")
drawHawkesIntensityPaper(lambda0=model1_par_est$lambda0,
                         alpha=model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                                   model1_par_est$f[plot.j],
                                                   model1_par_est$eta_1,
                                                   model1_par_est$eta_2,
                                                   model1_par_est$eta_3),
                         beta=model1_par_est$beta,
                         events=temp.t,
                         color=add.alpha(model_colors[1],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])

## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)


legend(legend.x[1],legend.y[1],c("True"),
       col = c("black"),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)
legend(legend.x[1]+18,legend.y[1],c("C-HP"),
       col = c(model_colors[1]),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-4,10), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m1$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now ###
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.positive,0),col=positive.col,border=NA)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model2
############
mod_drawHawkesIntensityPaper(lambda0 = true.object$lambda0,
                             alpha = true.object$alpha,
                             beta = true.object$beta,
                             events = temp.t,
                             add = FALSE,
                            yupper=y.ub[1],
                            color=add.alpha("black", alpha=line.alpha[1]),
                            line.width=line.wdth[1],
                            y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                            title_name=paste(plot.i,"->",plot.j),
                            title.cex = 2,
                            box.type="n")
drawHawkesIntensityPaper(lambda0=model2_par_est$gamma[plot.i]+
                           model2_par_est$zeta[plot.j],
                         alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                                                   model2_par_est$f[plot.j],
                                                   model2_par_est$eta_1,
                                                   model2_par_est$eta_2,
                                                   model2_par_est$eta_3),
                         beta=model2_par_est$beta,
                         events=temp.t,
                         color=add.alpha(model_colors[2],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])
legend(legend.x[2],legend.y[2],"C-DCHP",
       col = model_colors[2],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty = 1, lwd = 5, cex= legend.cex,seg.len=1)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(legend.x[2]-40,
       legend.y[2]+2,c("State 0/1 events","State change point"),
       col = c(NA,"red"),
       y.intersp=0.85,x.intersp=-0.1, bty = "n",
       pch = c(NA,4), pt.cex = c(NA,2), cex=legend.cex,
       lty = c(NA,NA), lwd=c(NA,4))
points(legend.x[2]-35,16,pch=1,cex=2,col="blue")
points(legend.x[2]-34,16,pch=16,cex=2,col="blue")

## delta lambda
par(mar = c(0,0.3,0,0.1))
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t

plot(lambda.true$time.vec,delta.lambda,xlim=c(0,my.xlim), ylim=c(-3,10), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model3
########
par(mar = c(0,0.3,1,0.1))
mod_drawHawkesIntensityPaper(lambda0 = true.object$lambda0,
                             alpha = true.object$alpha,
                             beta = true.object$beta,
                             events = temp.t,
                             add = FALSE,
                            yupper=y.ub[1],
                            color=add.alpha("black", alpha=line.alpha[1]),
                            line.width=line.wdth[1],
                            y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                            title_name=paste(plot.i,"->",plot.j),
                            title.cex = 2,
                            box.type="n")
drawUniMMHPIntensityPaper(object_hat,
                          simulation = list(
  x=state.est.latent.mmhp.new$x.hat,                                          
  z=state.est.latent.mmhp.new$z.hat,
  tau=temp.t,
  lambda.max=max(lambda.m3)),
                          yupper=y.ub,add=TRUE,
                          color=add.alpha(model_colors[3],
                                      alpha=line.alpha[2]),
  line.width=line.wdth[2])
legend(legend.x[3],legend.y[3],"C-MMHP",
       col = model_colors[3],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty =1, lwd = 5,cex=legend.cex,seg.len=1)
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(legend.x[3]-40,
       legend.y[3],c("Overestimation","Underestimation"),
       col = c(positive.col,negative.col),
       y.intersp=0.88,x.intersp=0.5,bty = "n",
       lty = c(1,1), lwd = c(10,10), cex=legend.cex,seg.len=0.8)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-12,8), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m3-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


## top
mtext(text="M1 Sim",side=3,line=0.8,outer=TRUE,cex=2.5,font=2)
## bottom
mtext(text="Time",side=1,line=2,outer=TRUE,cex=2.5)
## left
mtext(text="Intensity",side=2,line=0.6,outer=TRUE,cex=2.5)

```


```{r process m2 for fig4b, include=extra_plots, eval=extra_plots}
plot.s <- 1#7#9
plot.i <- 4
plot.j <- 5

cur_i <- plot.i
cur_j <- plot.j

load(paste0(m2_path,m2_files[plot.s]))
clean_sim_data_m2 <- cleanSimulationData(raw_data = sim_model2_data[[1]], 
                                      cut_off = cut_off,
                                      N = length(object_par$f_vec_1))

temp.t <- sim_model2_data[[1]]$day_hour[ which(sim_model2_data[[1]]$start == cur_i & 
                  sim_model2_data[[1]]$end == cur_j)]
# temp.t <- test.mmhp$tau
current.n <- length(temp.t)-1
time.segment <- seq(0,tail(temp.t,1),length.out=5000)

### Preprocess the model inference result
## model 1
#########
model1_par_est <- list(lambda0 = mean(sim_model2_stan_sim1_total[[plot.s]]$lambda0),
                       eta_1 = mean(sim_model2_stan_sim1_total[[plot.s]]$eta_1),
                       eta_2 = mean(sim_model2_stan_sim1_total[[plot.s]]$eta_2),
                       eta_3 = mean(sim_model2_stan_sim1_total[[plot.s]]$eta_3),
                       beta = mean(sim_model2_stan_sim1_total[[plot.s]]$beta),
                       f = apply(sim_model2_stan_sim1_total[[plot.s]]$f,2,mean))
lambda.m1<-uniHawkesIntensityNumeric(object=list(lambda0 = 
                                                   model1_par_est$lambda0,
                                    alpha =
                                      model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                    model1_par_est$f[plot.j],
                                    model1_par_est$eta_1,
                                    model1_par_est$eta_2,
                                    model1_par_est$eta_3),
                                    beta=model1_par_est$beta),
                                     events=temp.t,
                                     time.vec=time.segment)


## model2
#############
model2_par_est <- list(gamma = apply(sim_model2_stan_sim2_total[[plot.s]]$gamma,
                                   2,mean),
                    zeta = apply(sim_model2_stan_sim2_total[[plot.s]]$zeta,2,mean),
                    eta_1 = mean(sim_model2_stan_sim2_total[[plot.s]]$eta_1),
                    eta_2 = mean(sim_model2_stan_sim2_total[[plot.s]]$eta_2),
                    eta_3 = mean(sim_model2_stan_sim2_total[[plot.s]]$eta_3),
                    beta = mean(sim_model2_stan_sim2_total[[plot.s]]$beta),
                    f = apply(sim_model2_stan_sim2_total[[plot.s]]$f, 2, mean))

lambda.m2 <- uniHawkesIntensityNumeric(object=list(
  lambda0 = model2_par_est$gamma[plot.i]+
          model2_par_est$zeta[plot.j],                                        
  alpha = model1_fn$alpha.fun(model2_par_est$f[plot.i],
                            model2_par_est$f[plot.j],
                            model2_par_est$eta_1,
                            model2_par_est$eta_2,
                            model2_par_est$eta_3),
                beta = model2_par_est$beta),
                events = temp.t,
                time.vec = time.segment)

## Model3
#############
lam0_vec <- apply(sim_model2_stan_sim3_total[[plot.s]]$lambda0, 2, mean)
lam1_vec <- apply(sim_model2_stan_sim3_total[[plot.s]]$lambda1, 2, mean)

lam0_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                       ncol = length(object_par$f_vec_1))
lam1_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                       ncol = length(object_par$f_vec_1))

for(i in seq_along(lam0_vec)) {
  row_id <- clean_sim_data_m2$I_fit
  col_id <- clean_sim_data_m2$J_fit
  lam0_par_est[row_id, col_id] <- lam0_vec[i]
  lam1_par_est[row_id, col_id] <- lam1_vec[i]
}


mmhp_par_est <- list(lambda0 = lam0_par_est,
                     lambda1 = lam1_par_est,
                     eta_1 = mean(sim_model2_stan_sim3_total[[plot.s]]$eta_1),
                     eta_2 = mean(sim_model2_stan_sim3_total[[plot.s]]$eta_2),
                     eta_3 = mean(sim_model2_stan_sim3_total[[plot.s]]$eta_3),
                     beta = mean(sim_model2_stan_sim3_total[[plot.s]]$beta),
                     f = apply(sim_model2_stan_sim3_total[[plot.s]]$f,2,mean))

object_hat <- list(lambda0 = mmhp_par_est$lambda0[cur_i, cur_j],
                   lambda1 = mmhp_par_est$lambda1[cur_i, cur_j],
                   alpha = model3_fn$alpha.fun(mmhp_par_est$f[cur_i],
                                             mmhp_par_est$f[cur_j],
                                             mmhp_par_est$eta_1,
                                             mmhp_par_est$eta_2),
                   beta=mmhp_par_est$beta,
                   q1=model3_fn$q1.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3),
                   q2=model3_fn$q0.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3))


state_est_fits <- list.files(m2_path, pattern = "fit123_state_est_M2*")
load(paste0(m2_path,state_est_fits[plot.s]))

state.est.latent.mmhp <- interpolate_state_est_lst[plot.i,plot.j][[1]]
state.est.latent.mmhp.new <- fixInterpolateState(state.est.latent.mmhp,
                                                 termination=200)

step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,
                        2-state.est.latent.mmhp$z.hat)

lambda.m3 <- mmhpIntensityNumeric(params = object_hat,
                                  t = temp.t,
                                  time.vec = time.segment,
                                  latent.vec = step.fun.est(time.segment))

object_true <- lapply(object_matrix,function(x) x[plot.i,plot.j])
names(object_true) <- c("lambda0","lambda1","alpha","beta")


lambda.true <- uniHawkesIntensityNumeric(object = object_true,
                                        events =temp.t,
                                        time.vec = time.segment)
```

```{r fig 4b M2 sim, include=extra_plots, eval=extra_plots}
source(here("lib","mod_drawHawkesIntensityPaper.R"))
y.ub <- c(17,17,17)#c(130,72,31)
x_events <- 135#150
#model_colors <- c("steelblue", "goldenrod2", "firebrick2")
model_colors <- viridis::viridis(3)
layout(matrix(c(1:6), 6, 1), heights=rep(c(2.5,1),3))
layout(matrix(c(1:6), 6, 1), heights=rep(c(7.5,1),3))
my.xlim <- 140#160#200#130
my.long.x <- 140#205#134.5
legend.x <- c(50,50,50)#c(135,135,135)
legend.y <- #c(34,32,32)
legend.y <- c(15,12,15)#c(62,37,18)#c(22,22,22)
legend.cex <- 1.5 #3
line.alpha <- c(0.9,0.6)
line.wdth <- c(2,2.5)
negative.col <- add.alpha('lightskyblue',0.6)
positive.col <- add.alpha('tomato',0.6)
#negative.col <- viridis::viridis(5,alpha = 0.6)[1]
#positive.col <- viridis::viridis(5,alpha = 0.6)[4]
par(mar = c(0,0.3,0,0.1), oma = c(3,3.5,4,0),
    tcl=0.2,mgp=c(0.5,0,0), xpd=TRUE)

# model1
############
true.object <- object_true
# lambda.true$lambda.t <- lambda.est
# lambda.true$time.vec <- lambda.m1$time.vec

mod_drawHawkesIntensityPaper(lambda0 = true.object$lambda0,
                             alpha = true.object$alpha,
                             beta = true.object$beta,
                             events = temp.t,
                             add = FALSE,
                            yupper=y.ub[1],
                            color=add.alpha("black", alpha=line.alpha[1]),
                            line.width=line.wdth[1],
                            y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                            title_name=paste(plot.i,"->",plot.j),
                            title.cex = 2,
                            box.type="n")
drawHawkesIntensityPaper(lambda0=model1_par_est$lambda0,
                         alpha=model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                                   model1_par_est$f[plot.j],
                                                   model1_par_est$eta_1,
                                                   model1_par_est$eta_2,
                                                   model1_par_est$eta_3),
                         beta=model1_par_est$beta,
                         events=temp.t,
                         color=add.alpha(model_colors[1],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])

## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)


legend(legend.x[1],legend.y[1],c("True"),
       col = c("black"),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)
legend(legend.x[1]+18,legend.y[1],c("C-HP"),
       col = c(model_colors[1]),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-4,10), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m1$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now ###
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.positive,0),col=positive.col,border=NA)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model2
############
mod_drawHawkesIntensityPaper(lambda0 = true.object$lambda0,
                             alpha = true.object$alpha,
                             beta = true.object$beta,
                             events = temp.t,
                             add = FALSE,
                            yupper=y.ub[1],
                            color=add.alpha("black", alpha=line.alpha[1]),
                            line.width=line.wdth[1],
                            y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                            title_name=paste(plot.i,"->",plot.j),
                            title.cex = 2,
                            box.type="n")
drawHawkesIntensityPaper(lambda0=model2_par_est$gamma[plot.i]+
                           model2_par_est$zeta[plot.j],
                         alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                                                   model2_par_est$f[plot.j],
                                                   model2_par_est$eta_1,
                                                   model2_par_est$eta_2,
                                                   model2_par_est$eta_3),
                         beta=model2_par_est$beta,
                         events=temp.t,
                         color=add.alpha(model_colors[2],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])
legend(legend.x[2],legend.y[2],"C-DCHP",
       col = model_colors[2],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty = 1, lwd = 5, cex= legend.cex,seg.len=1)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(10,legend.y[2]+2,c("State 0/1 events","State change point"),
       col = c(NA,"red"),
       y.intersp=0.85,x.intersp=-0.1, bty = "n",
       pch = c(NA,4), pt.cex = c(NA,2), cex=legend.cex,
       lty = c(NA,NA), lwd=c(NA,4))
points(14,8+2,pch=1,cex=2,col="blue")
points(16,8+2,pch=16,cex=2,col="blue")

## delta lambda
par(mar = c(0,0.3,0,0.1))
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t

plot(lambda.true$time.vec,delta.lambda,xlim=c(0,my.xlim), ylim=c(-3,10), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model3
########
par(mar = c(0,0.3,1,0.1))
mod_drawHawkesIntensityPaper(lambda0 = true.object$lambda0,
                             alpha = true.object$alpha,
                             beta = true.object$beta,
                             events = temp.t,
                             add = FALSE,
                            yupper=y.ub[1],
                            color=add.alpha("black", alpha=line.alpha[1]),
                            line.width=line.wdth[1],
                            y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                            title_name=paste(plot.i,"->",plot.j),
                            title.cex = 2,
                            box.type="n")
drawUniMMHPIntensityPaper(object_hat,
                          simulation = list(
  x=state.est.latent.mmhp.new$x.hat,                                          
  z=state.est.latent.mmhp.new$z.hat,
  tau=temp.t,
  lambda.max=max(lambda.m3)),
                          yupper=y.ub,add=TRUE,
                          color=add.alpha(model_colors[3],
                                      alpha=line.alpha[2]),
  line.width=line.wdth[2])
legend(legend.x[3],legend.y[3],"C-MMHP",
       col = model_colors[3],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty =1, lwd = 5,cex=legend.cex,seg.len=1)
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(10,legend.y[3],c("Overestimation","Underestimation"),
       col = c(positive.col,negative.col),
       y.intersp=0.88,x.intersp=0.5,bty = "n",
       lty = c(1,1), lwd = c(10,10), cex=legend.cex,seg.len=0.8)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-12,8), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m3-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


## top
mtext(text="M2 Sim",side=3,line=0.8,outer=TRUE,cex=2.5,font=2)
## bottom
mtext(text="Time",side=1,line=2,outer=TRUE,cex=2.5)
## left
mtext(text="Intensity",side=2,line=0.6,outer=TRUE,cex=2.5)

```





# Figure 5:
```{r data for fig 5,cache=TRUE}
# load(paste(sim_data_path,"sim_model3_fit123.RData",sep=''))
# load(paste(sim_data_path,"fit123_state_est.RData",sep=''))
####
#### load new format


## Initialize
N_array <- array(0, dim = c(n_sim, length(object_par$f_vec_1),
                         length(object_par$f_vec_1))) 
Lambda_model3_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                     length(object_par$f_vec_1))) 
Lambda_model1_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                     length(object_par$f_vec_1)))
Lambda_model2_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                     length(object_par$f_vec_1))) 
Lambda_true_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                   length(object_par$f_vec_1))) 
PR_model1_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                 length(object_par$f_vec_1)))
PR_model2_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                 length(object_par$f_vec_1))) 
PR_model3_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                 length(object_par$f_vec_1)))
PR_true_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                               length(object_par$f_vec_1))) 
KS_model1_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                 length(object_par$f_vec_1)))
KS_model2_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                 length(object_par$f_vec_1)))
KS_model3_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                    length(object_par$f_vec_1)))
KS_true_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                               length(object_par$f_vec_1)))
KS_p_model1_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                   length(object_par$f_vec_1)))
KS_p_model2_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                   length(object_par$f_vec_1)))
KS_p_model3_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                    length(object_par$f_vec_1)))
KS_p_true_array <- array(0, dim = c(n_sim,length(object_par$f_vec_1),
                                    length(object_par$f_vec_1)))

## Iteration on 50 simulations
for(s in c(1:n_sim)){
  load(paste0(sim_data_path,"sim_model3_fit123_",s,".RData"))
  load(paste(sim_data_path,"fit123_state_est_",s,".RData",sep=''))
  clean_sim_data <- cleanSimulationData(raw_data=sim_model3_data, 
                                        cut_off = cut_off,
                                        N = length(object_par$f_vec_1))
  
  N_array[s,,] <- clean_sim_data$N_count
  
  ## model 1
  #########
  model1_par_est <- list(lambda0 = mean(sim_model3_stan_sim1$lambda0),
                         eta_1 = mean(sim_model3_stan_sim1$eta_1),
                         eta_2 = mean(sim_model3_stan_sim1$eta_2),
                         eta_3 = mean(sim_model3_stan_sim1$eta_3),
                         beta = mean(sim_model3_stan_sim1$beta),
                         f = apply(sim_model3_stan_sim1$f, 2, mean))
  
  for(i in c(1:5)){
    for(j in c(1:5)[-i]){
      current_t <- sim_model3_data$mmhp_matrix[i,j][[1]]$tau
      m1_object <- list(lambda0 = model1_par_est$lambda0,
                        alpha = model1_fn$alpha.fun(model1_par_est$f[i],
                                                  model1_par_est$f[j],
                                                  model1_par_est$eta_1,
                                                  model1_par_est$eta_2,
                                                  model1_par_est$eta_3),
                        beta = model1_par_est$beta)
      Lambda_model1_array[s,i,j] <- 
        uniHawkesIntegralIntensity(object = m1_object, 
                                   events = current_t,
                                   termination = tail(current_t,1))
      Lambda_test <- uniHawkesCompensator(object = m1_object, 
                                          events = current_t)
      KS_model1_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$statistic
      KS_p_model1_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$p.value
      PR_model1_array[s,i,j] <- uniHawkesPearsonResidual(object = m1_object, 
                                                         events = current_t,
                                                         termination = 
                                                           tail(current_t,1))
    }
  }
  
  ## model2
  #############
  model2_par_est <- list(gamma = apply(sim_model3_stan_sim2$gamma, 2, mean),
                         zeta = apply(sim_model3_stan_sim2$zeta,2,mean),
                         eta_1 = mean(sim_model3_stan_sim2$eta_1),
                         eta_2 = mean(sim_model3_stan_sim2$eta_2),
                         eta_3 = mean(sim_model3_stan_sim2$eta_3),
                         beta = mean(sim_model3_stan_sim2$beta),
                         f = apply(sim_model3_stan_sim2$f, 2, mean))
  
  for(i in c(1:5)){
    for(j in c(1:5)[-i]){
      current_t <- sim_model3_data$mmhp_matrix[i,j][[1]]$tau
      m2_object <- list(lambda0 = model2_par_est$gamma[i] + 
                          model2_par_est$zeta[j],
                        alpha = model1_fn$alpha.fun(model2_par_est$f[i],
                                                    model2_par_est$f[j],
                                                    model2_par_est$eta_1,
                                                    model2_par_est$eta_2,
                                                    model2_par_est$eta_3),
                        beta = model2_par_est$beta)
      Lambda_model2_array[s,i,j] <-
        uniHawkesIntegralIntensity(object = m1_object, 
                                   events = current_t,
                                   termination = tail(current_t,1))
      Lambda_test <- uniHawkesCompensator(object = m2_object,
                                          events = current_t)
      KS_model2_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$statistic
      KS_p_model2_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$p.value
      PR_model2_array[s,i,j] <- 
        uniHawkesPearsonResidual(object = m2_object, 
                                 events = current_t,
                                 termination = tail(current_t,1))
    }
  }
  
  ## Model3 & true model
  ######
  lambda_0_est <- apply(sim_model3_stan_sim3$lambda0, 2, mean)
  lambda_1_est <- apply(sim_model3_stan_sim3$lambda1, 2, mean)
  ## then put these into a matrix
  lam0_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                         ncol = length(object_par$f_vec_1))
  lam1_par_est <- matrix(0, nrow = length(object_par$f_vec_1),
                         ncol = length(object_par$f_vec_1))
  for(i in seq_along(lambda_0_est)) {
    row_id <- clean_sim_data$I_fit[i]
    col_id <- clean_sim_data$J_fit[i]
    lam0_par_est[row_id, col_id] <- lambda_0_est[i]
    lam1_par_est[row_id, col_id] <- lambda_1_est[i]
  }
  mmhp_par_est <- list(lambda0 = lam0_par_est,
                       lambda1 = lam1_par_est,
                       eta_1 = mean(sim_model3_stan_sim3$eta_1),
                       eta_2 = mean(sim_model3_stan_sim3$eta_2),
                       eta_3 = mean(sim_model3_stan_sim3$eta_3),
                       beta = mean(sim_model3_stan_sim3$beta),
                       f = apply(sim_model3_stan_sim3$f,2,mean))
  clean_sim_data <- cleanSimulationData(raw_data = sim_model3_data, 
                                        cut_off = cut_off,
                                        N = length(object_par$f_vec_1))
  
  for(i in c(1:5)){
    for(j in c(1:5)[-i]){
      test.mmhp <- sim_model3_data$mmhp_matrix[i,j][[1]]
      temp.t <- test.mmhp$tau
      current.n <- length(temp.t)-1
      time.segment <- seq(0,tail(temp.t,1),length.out=10000)
      
      object_hat <- list(lambda0=mmhp_par_est$lambda0[i,j],
                         lambda1=mmhp_par_est$lambda1[i,j],
                         alpha=model3_fn$alpha.fun(mmhp_par_est$f[i],
                                                   mmhp_par_est$f[j],
                                                   mmhp_par_est$eta_1,
                                                   mmhp_par_est$eta_2),
                         beta=mmhp_par_est$beta,
                         q1=model3_fn$q1.fun(mmhp_par_est$f[i],
                                             mmhp_par_est$f[j],
                                             mmhp_par_est$eta_3),
                         q2=model3_fn$q0.fun(mmhp_par_est$f[i],
                                             mmhp_par_est$f[j],
                                             mmhp_par_est$eta_3))
      
      object_true <- lapply(object_matrix,function(x) x[i,j])
      names(object_true) <- c("lambda0","lambda1","alpha","beta","q1","q2")
      
      ## est Lmabda and [R]
      Lambda.test <- mmhpCompensator(params = object_hat, 
                                     t = temp.t,
                                     pzt=2 - 
                                       event_state_est_lst[i,j][[1]]$zt_v,
                                     if.pzt = FALSE)
      KS_model3_array[s,i,j] <-  ks.test(Lambda.test,"pexp")$statistic
      KS_p_model3_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$p.value
      state.est.latent.mmhp <- interpolate_state_est_lst[i,j][[1]]
      step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,
                              2 - state.est.latent.mmhp$z.hat)
      est.intensity <- mmhpIntensityNumeric(params = object_hat,
                                            t = temp.t[-1],
                                            time.vec = time.segment,
                                            latent.vec = 
                                              step.fun.est(time.segment))
      est.intensity.events <- mmhpIntensityAtEvents(params=object_hat,
                                                    t = temp.t,
                                  latent_z = 
                                    event_state_est_lst[i,j][[1]]$zt_v)
      Lambda_model3_array[s,i,j] <-
        sum(est.intensity)*(time.segment[2]-time.segment[1])
      PR_model3_array[s,i,j] <- sum(1/sqrt(est.intensity.events))-
        sum(sqrt(est.intensity))*(time.segment[2]-time.segment[1])
      
      ## Under the true model
      Lambda.test.true <- mmhpCompensator(params = object_true,
                                          t = temp.t,
                                          pzt = 2 - 
                                            test.mmhp$zt[2:length(test.mmhp$zt)],
                                          if.pzt=FALSE)
      KS_true_array[s,i,j] <-  ks.test(Lambda.test.true,"pexp")$statistic
      KS_p_true_array[s,i,j] <-  ks.test(Lambda.test.true,"pexp")$p.value
      true.intensity <- 
        mmhpTrueIntensityNumeric(params = object_true,
                                                 t = temp.t,
                                 latent = list(x = 
                                                fixStateTransition(test.mmhp)$x,
                                               z = 
                                                fixStateTransition(test.mmhp)$z),
                                     time.vec = time.segment)
      true.intensity.events <- mmhpIntensityAtEvents(params = object_true,
                                                     t = temp.t, 
                                                     latent_z = test.mmhp$zt)
      Lambda_true_array[s,i,j] <- sum(true.intensity$lambda.t)*(time.segment[2]-time.segment[1])
      PR_true_array[s,i,j] <- sum(1/sqrt(true.intensity.events))-
        sum(sqrt(true.intensity$lambda.t))*(time.segment[2]-time.segment[1])
    }
  }
}

```


```{r fig5a-residual-ks, fig.height=7}
# cols_plot <- col_df %>% filter(method %in% c("C-HP","C-DCHP","C-MMHP",
#                                              "True"))

cols_plot <- col_df %>% filter(method %in% c("C-HP","C-DCHP","C-MMHP",
                                 "True")) %>%
  arrange(factor(method, levels = c("C-HP","C-DCHP","C-MMHP","True"))) %>%
  pull(cols)
#load("../output/sim_model3_fit123_residuals.RData")
par(mfrow=c(5,5),mar=c(0.2,0.2,0.2,0.2),oma=c(2.4,2.4,2.9,0.5))
for(i in c(5:1)){
  for(j in c(5:1)){
    if(i==j){
      plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),
           bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
      if(i==5){
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04, 
                col = cols_plot[1], border = NA)
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04-0.22,
                col = cols_plot[2], border = NA)
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04-0.44,
                col = cols_plot[3], border = NA)
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04-0.66,
                col = cols_plot[4], border = NA)
        text(c(0.43,0.58,0.61,0.4), seq(0.8,0.14,-0.22),
             c("C-HP", "C-DCHP", "C-MMHP", "True"),
             cex=1.7)
      }
    }else{
      # PR <- c((N_array-Lambda_model1_array)[,i,j],(N_array-Lambda_model2_array)[,i,j],
      #         (N_array-Lambda_model3_array)[,i,j],(N_array-Lambda_true_array)[,i,j])
      PR <- c(KS_model1_array[,i,j], KS_model2_array[,i,j],
              KS_model3_array[,i,j], KS_true_array[,i,j])
      ### try pr scores instead
      # PR <- c(PR_model1_array[,i,j],PR_model2_array[,i,j],
      #         PR_model3_array[,i,j],PR_true_array[,i,j])
      Type <- c(rep(1,n_sim), rep(2,n_sim), rep(3,n_sim), rep(4,n_sim))
      boxplot(PR ~ Type,  
              col = cols_plot,
              #col = c("steelblue", "goldenrod2", "firebrick2", "chartreuse3"),   
              xlab="",ylab="",xaxt="n",yaxt="n")
      #names = c("C-HP", "C-HP-DC", "C-MMHP", "True")
    }
  }
}
mtext(text=c(1:5), side=2, line=0.5, outer=TRUE, cex=2, las=2,
      at=c(0:4)/5+0.1)
mtext(text=c(5:1), side=1, line=1.5, outer=TRUE, cex=2,
      at=c(0:4)/5+0.1)
mtext(text="(a)",side=3,line=0.5,outer=TRUE,cex=2.5,font=2)


```


# Figure 5b: Simulation Spearman Rank
```{r fig-5b-spearman-sim, fig.height=7}
sim_files <- list.files(here("output", "sims_m3_update"), 
                        pattern = "rank_sim")

all_sims <- list()
for(i in seq_along(sim_files)) {
 single_fit <- readRDS(here("output", "sims_m3_update",
                            sim_files[i]))
 all_sims[[i]] <- single_fit
}

spear <- function(sim_data) {
  truth <- sim_data$truth
  sim_data %>%
    select(m1:glicko) %>%
    purrr::map( ~cor.test(truth, .x,
                   method = "spearman")$estimate  ) %>%
    enframe() %>%
    unnest(cols = c(value))
}


sim_data <- map_dfr(all_sims, spear) 

name <- sim_data$name

sim_data$name <- case_when(
          name == "isi" ~ "I&SI",
          name == "m1" ~ "C-HP",
          name == "m2" ~ "C-DCHP",
          name == "m3_dc" ~ "C-MMHP",
          name == "agg" ~ "AggRank",
          name == "glicko" ~ "Glicko")

sim_data$name <- factor(sim_data$name, levels = c("I&SI",
                                                  "AggRank",
                                                  "Glicko",
                                                  "C-HP",
                                                  "C-DCHP",
                                                  "C-MMHP"))

plot_cols <- col_df %>% filter(method %in% levels(sim_data$name)) %>%
  pull(cols)
  
sim_data %>%
  rename(Method = name, corr = value) %>%
  ggplot(aes(Method,corr)) + 
  geom_boxplot(aes(fill = Method), alpha = 0.7) +
  scale_fill_manual(values = plot_cols) +
  labs(y = "Rank Correlation") + theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        legend.position="right") + ggtitle("(b)")
```


# Figure 6: Latent Rank Cohort comparison


## Figure 6a: Rank vs I&SI


```{r fig-6a-rank-vs-isi}
### Rank Comparison for Single Cohort ####
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/agg_rank_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_mmhp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))

no_method <- 4
plot_latent_df <- data.frame(Methods=rep(1:no_method,each=1000*mice_number),
                             Mice=rep(rep(1:mice_number,each=1000),no_method),
                             force=rep(0,1000*mice_number*no_method))
## agg
plot_latent_df$force[(1:(1000*mice_number))] <- as.vector(sim_agg_rank$x[1001:2000,])

## M1
plot_latent_df$force[(1:(1000*mice_number))+1000*mice_number] <- as.vector(sim_cohort_hp$f)

## M2
plot_latent_df$force[(1:(1000*mice_number))+2000*mice_number] <- as.vector(sim_cohort_dchp$f)

## M3
plot_latent_df$force[(1:(1000*mice_number))+3000*mice_number] <- as.vector(sim_cohort_mmhp$f)

plot_latent_df$Mice <- factor(plot_latent_df$Mice,
                              levels = expert_rank_10[[current_cohort]])
plot_latent_df$Method <- factor(plot_latent_df$Method,
                                labels = c("AggRanking","C-HP","C-DCHP","C-MMHP"))

# png(paste(plot_path,"real_rank_one_cohort.png",sep=""),width=600,height=300)
plot_cols <- col_df %>% filter(method %in% c("AggRank", "C-HP",
                                "C-DCHP", "C-MMHP")) %>%
  pull(cols)


p1 <- ggplot(plot_latent_df, 
             aes(x = Mice, y = force, fill = Method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = plot_cols)+
  #scale_fill_manual(values = c("gray", "steelblue", "goldenrod2" , "firebrick2")) +
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 10),
        legend.position="none") +
  facet_grid(cols=vars(Method)) +
  xlab("Mice (ranked by I&SI method)") +
  ylab("Latent rank")
p1
#dev.off()

```
## Figure 6b: Spearman rank correlation



```{r fig-6b-overall-rank-correlation}
load("../output/weighted_rank_data.RData")
#png(paste(plot_path,"real_rank_all_cohort.png",sep=""),width=600,height=300)
no_method <- 4
plot_cor_df <- data.frame(Method=rep(c(1:no_method),each=10),
                          cor=as.vector(spearman_df))
plot_cor_df$Method <- factor(plot_cor_df$Method,
                             labels = c("Agg-rank","C-HP","C-DCHP","C-MMHP"))
p2 <- ggplot(plot_cor_df, aes(x="", y = cor, fill = Method)) +
        geom_boxplot(alpha=0.7, width=0.5) +
        scale_fill_manual(values = plot_cols) + 
        ggtitle("(b)") +
        ylim(0,1) +
        theme_bw() +
        theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
              text = element_text(size = 20),
              axis.text.y =element_text(size = 11),
              legend.position="none",
              axis.title.x=element_blank()) +
        facet_grid(cols=vars(Method)) +
        ylab("Spearman rank correlation")
p2


```



# Figure 7: Pearson residual matrices



```{r fig-7-prMatrix-Cohort3, fig.width=7, fig.height=7}
current_cohort <- 3
## 2 and 8 maybe look better
## 3 probably looks the best

m1_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                   "/chp_pr_matrix_",cohort_names[current_cohort],
                   ".RDS",sep=''))

m2_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/dchp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

m3_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/cmmhp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

indep_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/immhp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

matrix_lst_plot <- list(
                        indep_pr[rev(expert_rank_10[[current_cohort]]),
                                                                   expert_rank_10[[current_cohort]]],
                        m1_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]],
                        m2_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]],
                        m3_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]]) 
#cat("Cohort ",current_cohort,"\n",sep="")
myMultiMatrixPlot(X=matrix_lst_plot,no_matrix=4,n_row=2,
                  xLabels=expert_rank_10[[current_cohort]],
                  yLabels=rev(expert_rank_10[[current_cohort]]),
                  min=-80,max=80,axis_cex=2,title_cex = 1.8,
                  colorPalette="RdBu",if.emp=FALSE,
                  #legend.mar=c(0.5,.5,0.5,0.5),
                  title_lst=list("I-MMHP","C-HP","C-DCHP","C-MMHP"), 
                  #title_lst = list("I-MMHP"),
                  col_axis=c(-80,-40,0,40,80), fake_matrix=FALSE,
                  matrix.mar=c(2.5,2.5,2.5,1)
                  )
# mtext(text="(a)",side=3,line=0.5,outer=TRUE,cex=2.5,font=2)


```

```{r fig-7b-matrix-structure-score, fig.width=7, fig.height=7}
library(NMF)
source(here("lib","residualStructureScore.R"))

struct_scores <- tibble()
for(current_cohort in 1:10) {
  m1_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                   "/chp_pr_matrix_",cohort_names[current_cohort],
                   ".RDS",sep=''))
  ##
  ## remove animals which are never fought or don't ever fight
  prob_row <- which(rowSums(m1_pr) == 0)
  prob_col <- which(colSums(m1_pr) == 0)
  prob_id <- NA
  prob_id <- c(prob_row,prob_col)
  # print(prob_id)
  if(length(prob_id) != 0) {
    m1_pr <- m1_pr[-prob_id,-prob_id]
  }

  ##
  m2_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                       "/dchp_pr_matrix_",cohort_names[current_cohort],
                       ".RDS",sep=''))
  if(length(prob_id) != 0) {
    m2_pr <- m2_pr[-prob_id,-prob_id]
  }
  
  m3_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                       "/cmmhp_pr_matrix_",cohort_names[current_cohort],
                       ".RDS",sep=''))
  if(length(prob_id) != 0) {
    m3_pr <- m3_pr[-prob_id,-prob_id]
  }
  indep_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                       "/immhp_pr_matrix_",cohort_names[current_cohort],
                       ".RDS",sep=''))
  # print(range(as.vector(indep_pr)))
  if(length(prob_id) != 0) {
    indep_pr <- indep_pr[-prob_id,-prob_id]
  }
  if(current_cohort %in% c(8,10)) {
    # one additional row
    # print("in here")
    new_prob_row <- which(rowSums(m1_pr) == 0)
    new_prob_col <- which(colSums(m1_pr) == 0)
    prob_id <- c(new_prob_row,new_prob_col) 
    if(length(prob_id) != 0) {
      m1_pr <- m1_pr[-prob_id, -prob_id]
      m2_pr <- m2_pr[-prob_id, -prob_id]
      m3_pr <- m3_pr[-prob_id, -prob_id]
      indep_pr <- indep_pr[-prob_id, -prob_id]
    }
  }
  
  m1_score <-positiveNegativeApproxError(m1_pr)
  m2_score <- positiveNegativeApproxError(m2_pr)
  m3_score <- positiveNegativeApproxError(m3_pr) ## smallest value which is good
  ind_score <- positiveNegativeApproxError(indep_pr) 
  ## this doesn't make sense because all negative
  ## values
  current_score <- tibble(m1_score, m2_score, m3_score, ind_score)
  names(current_score) <- c("C-HP","C-DCHP","C-MMHP","I-MMHP")
  current_score$type <- c("Positive Residuals","Negative Residuals")
  current_score$Cohort <- current_cohort
  # current_score$resids <- list(m1 = m1_pr,
  #                              m2 = m2_pr,
  #                              m3 = m3_pr,
  #                              ind = indep_pr)
  struct_scores <-struct_scores %>% bind_rows(current_score)
}

struct_plot <- struct_scores %>% 
  rename(Pos_Neg = type) %>%
  pivot_longer(cols = "C-HP":"I-MMHP",
               names_to = "Method", values_to = "Score") 
  # filter(Score > 0) %>%
  # filter(Score < 0.99) %>%
  # filter(!(Method == "I-MMHP" & Pos_Neg == "Positive"))
  # mutate(Method = as.factor(Method, levels = c("I-MMHP","C-HP","C-DCHP",
  #                                              "C-MMHP"))) %>%
struct_plot$Method <- factor(struct_plot$Method, levels = c("I-MMHP","C-HP","C-DCHP",
                                               "C-MMHP") )

# box_cols <- col_df %>% 
#   filter(method %in% c("I-MMHP","C-HP","C-DCHP","C-MMHP")) %>%
#   pull(cols)

struct_plot %>% 
  ggplot(aes(Method,Score, fill = Method)) + geom_boxplot() + 
  # scale_fill_manual(values = box_cols) +
  ggtitle("(b)") +
  facet_wrap(~Pos_Neg) + theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
              text = element_text(size = 20),
              axis.text.y =element_text(size = 11),
              axis.text.x = element_blank(),
              axis.title.x=element_blank() )

```





# Figure 8

## Figure 8a: MAE of interaction predictions, single cohort

```{r fig-8a-frob-norm-cohort5, fig.width=8,fig.height=4,eval=FALSE}
load("../output/plot_N_predict.RData")
current_cohort <- 5# cohort 1 looks worse than rest

temp_plot_df <- predict_day_mae_df_lst[[current_cohort]]
temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
#png(paste(plot_path,"real_predict_N_one_cohort.png",sep=""),
# width=600,height=300)

plot_cols_pred <- col_df %>% 
  filter(method %in% levels(temp_plot_df$method)) %>%
   arrange(factor(method, levels = c("I-MMHP","DSNL",
                                     "C-HP", "C-DCHP", "C-MMHP"))) %>%
                    pull(cols)

p3 <- temp_plot_df %>%
  rowwise() %>%
  #mutate(norm = min(norm,60)) %>%
  # rename(Method = method) %>%
  ggplot( aes(x = method, y = mae, fill = method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = plot_cols_pred) +
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("MAE") +
  ylim(0, 8) + # aren't infinite but >150 and <200
  NULL
p3 + labs(fill = "Method")
```


## Figure 8b: Same plot aggregated for all cohorts


```{r fig-7a-pred-all-cohorts-box}
### updated to revision
load("../output/plot_N_predict_revision.RData")

all_cohort_box <- all_cohort_mae_df

all_cohort_box$method <- factor(all_cohort_box$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL",
                                         "C-HP","C-DCHP",
                                         "C-MMHP"))
all_cohort_box$day <- factor(all_cohort_box$day)


plot_cols_pred <- col_df %>% 
  filter(method %in% levels(all_cohort_box$method)) %>%
   arrange(factor(method, levels = c("I-MMHP","DSNL",
                                     "C-HP", "C-DCHP", "C-MMHP"))) %>%
                    pull(cols)

all_cohort_box %>% 
  ggplot(aes(x=method,y=norm, fill = method)) +
  # facet_grid(cols = vars(day)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = plot_cols_pred) +
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22,
                                  hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  # guides(color=guide_legend(title="Method")) +
  xlab("Prediction horizon (day)") + 
  ylab("Frobenius norm of error") +
  labs(fill = "Method") +
  # ylim(0, 80) +
  NULL


```



# Figure 9

## Figure 9a: Predicted Spearman rank for single cohort

```{r fig-9a-spearman-rank-cohort1, eval=FALSE}
load(here("output","plot_rank_predict.RData"))
# current_cohort <- 5
temp_plot_df <- predict_day_rank_df_lst[[current_cohort]]
temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP",
                                         "C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
# png(paste(plot_path,"real_predict_rank_one_cohort.png",sep=""),
# width=600,height=300)
p5 <- ggplot(temp_plot_df, aes(x = method, y = spearman, fill = method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = plot_cols_pred) +
  #scale_fill_manual(values =
  # c("gray","yellowgreen","steelblue","goldenrod2","firebrick2")) + 
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("Spearman rank correlation") +
  # ylim(0, 1) +
  NULL
p5 + labs(fill = "Method")
```



## Figure 9b: Predicted Spearman rank for all cohorts

```{r fig-7b-pred-rank-spearman-all-cohorts}
load("../output/plot_rank_predict.RData")

all_cohort_rank_df$method <- factor(all_cohort_rank_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP",
                                         "C-DCHP","C-MMHP"))

p7 <- ggplot(all_cohort_rank_df,
       aes(x=method, y=spearman, fill=method)) + 
  # geom_line(size=1.2, alpha=0.8, position=position_dodge(0.2)) +
  geom_boxplot(alpha = 0.7) +
  scale_fill_manual(values = plot_cols_pred) +
  ggtitle("(b)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position="right") +
  facet_grid(cols = vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("Spearman rank corr.") + 
  # coord_cartesian(ylim=c(0,1)) + 
  labs(fill = "Method")

p7

```


# Figure 10

## Figure 10a


```{r construct data for plot, results='hide',message=FALSE,cache=TRUE}
library(PlayerRatings)

current_cohort <- 7
# 4 best so far, or 7

load(paste(data_path,cohort_names[current_cohort],
           "/predict_simulation_",cohort_names[current_cohort],
           ".RData",sep=''))
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]],
                        cut_off = 1)

df <- full_data[[cohort_names[current_cohort]]]
df <- df[df$Actor!="Start"&df$Actor!="End",]
df1 <- expandrows(df)
df1 <- df1[order(df1$Timestamp),] #ensure in date order
df1$event <- 1:nrow(df1)
glick.df <- df1[, c("event","Actor","Recipient","score"), with = FALSE]
#need event, actor, recipient, score
gl <- my_glicko(glick.df, history=TRUE, cval=2)

# ------------------- period
training_end <- nrow(df[df$day<=18,])
testing_end <- nrow(df)-1#1077 #929 for cohort 5
newx <- c(training_end:testing_end)

# ----------------- set pars for plot
my_col <- c("black", "grey", "orange", "red")
col_vec <- colorRampPalette(my_col)(mice_number)
ltypes_vec <- rep(1,mice_number) #c(1,2,3,1,2,3,1,2,3,1,2,3)
history_width <- 3
sim_width <- 0.3
shade_vec <- makeTransparent(col_vec,0.2)
less_shade_vec <- makeTransparent(col_vec,0.7)

# ---------------- simulation mean and sd
sim_gl_array <- array(NA, dim=c(12,testing_end-training_end+1,1000))
for(s in 1:1000){
  print(s)
  temp_gl <- glickoScoreSimulationWithWindowsReturnAll(
    predict.sim = m3_predict_sim[5:8,s], #7 for c 2 and 10
    history.df = glick.df[1:training_end,])
  history_matrix <- temp_gl$history[,,1]
  
  if(testing_end>ncol(temp_gl$history[,,1])){
    history_matrix <- cbind(history_matrix,
                            t(matrix(rep(history_matrix[,ncol(history_matrix)],
                                         testing_end-ncol(temp_gl$history[,,1])),
                                     nrow=testing_end-ncol(temp_gl$history[,,1]),
                                     byrow=TRUE)))
  }else{
    # try(
    history_matrix <- history_matrix[,1:testing_end]#temp_gl$history[,1:testing_end]
    # )
  }
  sim_gl_array[,,s] <- history_matrix[,training_end:testing_end]
}
```



```{r fig-10a-glicko-rating}
par(mar=c(3,5,3,1))
testing_end <- testing_end - 1
plot(1, type="n", xlab="", ylab="Glicko ranking", xlim=c(0,dim(gl$history)[2]),
     ylim=c(min(gl$history[,,1]),max(gl$history[,,1])),
     cex.axis=2, cex.lab=2)
for(m in c(1:mice_number)){
  #history
  lines(gl$history[m,1:training_end,1],
        cex=0.6, col=col_vec[m],lwd=history_width,lty=ltypes_vec[m])
  lines(c(rep(NA,training_end), gl$history[m,(training_end+1):testing_end,1]),
        cex=0.6, col=shade_vec[m],lwd=history_width,lty=ltypes_vec[m])
  
  #simulation
  cur_end <- testing_end
  mean_vec <- apply(sim_gl_array[m,,],1,function(x) mean(na.omit(x)))
  sd_vec <- apply(sim_gl_array[m,,],1,function(x) sd(na.omit(x)))
  polygon(c(newx, rev(newx)), c(mean_vec-sd_vec,rev(mean_vec+sd_vec)),col = shade_vec[m], border = NA)
  #polygon(c(newx), c(mean_vec-sd_vec),col = shade_vec[m], border = NA)
  lines(c(rep(NA,training_end),mean_vec),
        cex=0.6, col=col_vec[m],lwd=1,lty=2)
}

# annotate the days
for(d in c(19:21)){
  abline(v = nrow(df[df$day<=(d-1),]),lty=2,lwd=0.4)
  text(x=nrow(df[df$day<=(d-1),]),y=2600,d)
}
mtext(text="(a)", side=3, line=-2.3, outer=TRUE, cex=2.8, at=0.5, font=2)
```

```{r fig-glicko-pred-slides,eval=slides_plots,include=slides_plots}
par(mar=c(3,5,3,1))
plot(1, type="n", xlab="", ylab="Glicko ranking", xlim=c(0,dim(gl$history)[2]),
     ylim=c(min(gl$history[,,1]),max(gl$history[,,1])),
     cex.axis=2, cex.lab=2)
for(m in c(1:mice_number)){
  #history
  lines(gl$history[m,1:training_end,1],
        cex=0.6, col=col_vec[m],lwd=history_width,lty=ltypes_vec[m])
  lines(c(rep(NA,training_end), gl$history[m,(training_end+1):testing_end,1]),
        cex=0.6, col=shade_vec[m],lwd=history_width,lty=ltypes_vec[m])
  
  #simulation
  cur_end <- testing_end
  mean_vec <- apply(sim_gl_array[m,,],1,function(x) mean(na.omit(x)))
  sd_vec <- apply(sim_gl_array[m,,],1,function(x) sd(na.omit(x)))
  polygon(c(newx, rev(newx)), c(mean_vec-sd_vec,rev(mean_vec+sd_vec)),
          col = shade_vec[m], border = NA)
  #polygon(c(newx), c(mean_vec-sd_vec),col = shade_vec[m], border = NA)
  lines(c(rep(NA,training_end),mean_vec),
        cex=0.6, col=col_vec[m],lwd=1,lty=2)
}

# annotate the days
for(d in c(19:21)){
  abline(v = nrow(df[df$day<=(d-1),]),lty=2,lwd=0.4)
  text(x=nrow(df[df$day<=(d-1),]),y=2600,d)
}
#mtext(text="(a)", side=3, line=-2.3, outer=TRUE, cex=2.8, at=0.5, font=2)
```




```{r remove some objects, include=FALSE}
rm(m3_predict_sim)
rm(m2_predict_sim)
rm(m1_predict_sim)
rm(mmhp_predict_sim)
rm(fit_agg_rank)
rm(fit_cohort_hp)
rm(fit_cohort_dchp)
rm(fit_cohort_mmhp)

# also removing stan fits as they can cause issues in the next chunk

```


## Fig 10b

```{r process for state separation cohort1,eval=FALSE}
# only run this once and save the results
# this doesn't need to be rerun ever, even if the stan fits change
# current_cohort <- 1

load(paste(data_path,cohort_names[current_cohort],
             "/cmmhp_est_zt_",cohort_names[current_cohort],
             ".RData",sep=''))
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("day","observe.id","observe.time")])

## 5.  find how many 1s for each pair
print(".......state separation plot........")
total_event_array <- array(0,dim = c(mice_number, mice_number,
                                   max(return_df$observe.id)))
active_event_array <- array(0,dim = c(mice_number, mice_number,
                                    max(return_df$observe.id)))

for(i in 1:mice_number){
  for(j in c(1:mice_number)[-i]){
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0){
      current_window_vec <- unique_pairs_df$observe[[pair]]
      for(cur_win in current_window_vec){
        row_indicator <- return_df$initiator==i&return_df$recipient==j&return_df$observe.id==cur_win
        total_event_array[i,j,cur_win] <- length(return_df[row_indicator,"event.times"][[1]])
        active_event_array[i,j,cur_win] <- sum(apply(2-state_array_list[[pair]][[cur_win]],1,mean) > 0.5)
      }
    }
  }
}

utility_state_day <- array(0,dim=c(21,mice_number,mice_number))
social_state_day <- array(0,dim=c(21,mice_number,mice_number))
for(cur_day in c(1:21)){
  cur_wins <- which(unique_observe_win$day==cur_day)
  utility_state_day[cur_day,,] <- apply(active_event_array[,,cur_wins],
                                        c(1, 2), sum)
  social_state_day[cur_day,,] <- apply(total_event_array[,,cur_wins], 
                                       c(1, 2), sum) - 
    utility_state_day[cur_day,,]
}


## utility dsnl
fit_dsnl_active <- stan("../lib/dsnl_poisson.stan",
                         data=list(day=21,
                                   Gt=utility_state_day,
                                   c=1,
                                   sigma=0.5),
                         iter=1000, chains=4, control=list(adapt_delta=0.99))
print(fit_dsnl_active,pars=c("x"))
sim_dsnl_active <- rstan::extract(fit_dsnl_active)

## social dsnl
fit_dsnl_inactive <- stan("../lib/dsnl_poisson.stan",
                           data=list(day=21,
                                     Gt=social_state_day,
                                     c=1,
                                     sigma=1),
                           iter=1000, chains=4, control=list(adapt_delta=0.99))
print(fit_dsnl_inactive,pars=c("x"))
sim_dsnl_inactive <- rstan::extract(fit_dsnl_inactive)

save(sim_dsnl_active, fit_dsnl_active, utility_state_day,
     sim_dsnl_inactive, fit_dsnl_inactive, social_state_day,
     file = paste(data_path,cohort_names[current_cohort],
                  "/dsnl_state_separation_stan_result_",
                  cohort_names[current_cohort],
                  ".RData",sep=''))
rm(interpolation_array_list)
rm(state_array_list)
rm(termination_state_list)
rm(initial_state_list)
```


```{r process data for plot 10b, cache=TRUE}
library(PlayerRatings)
# current_cohort <- 5
current_cohort <- 1
load(paste(data_path,cohort_names[current_cohort],
           "/dsnl_poisson_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/dsnl_state_separation_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
sub.types <- c("All", "Active", "Inactive"); # three methods
task.types <- paste0("day", 1:21);  

data.tbl <- data.frame(array(NA, c(2000*3*21, 3)))
colnames(data.tbl) <- c("sub.type", "task.type", "data.value")  
source('../lib/myGlicko.R')
#------------ gl score
df <- full_data[[cohort_names[current_cohort]]]
df <- df[df$Actor!="Start"&df$Actor!="End",]
df1 <- expandrows(df)
df1 <- df1[order(df1$Timestamp),] #ensure in date order
df1$event <- 1:nrow(df1)
glick.df <- df1[, c("event","Actor","Recipient","score"), with = FALSE] #need event, actor, recipient, score
real.gl <- my_glicko(glick.df, history=TRUE, cval=2)
clean_data_all <- cleanData(full_data[[cohort_names[current_cohort]]],
                              cut_off = 1)
day_end_idx <- unlist(lapply(c(1:21),function(x) 
  max(which(clean_data_all$day==x))))

## All aggregate
for (t in 1:length(task.types)){
  temp_vec <- rep(NA,2000)
  cur_real_rank <- real.gl$history[,day_end_idx[t],1]
  for(s in c(1:2000)){
    temp_result <- cor.test(sim_dsnl$x[s,t,], cur_real_rank,
                            method = "spearman")
    temp_vec[s] <- temp_result$estimate
  }
  data.tbl$sub.type[(1:2000)+(t-1)*2000] <- sub.types[1]  
  data.tbl$task.type[(1:2000)+(t-1)*2000] <- task.types[t];  
  data.tbl$data.value[(1:2000)+(t-1)*2000] <- temp_vec
}  

## Utility aggregate
for (t in 1:length(task.types)){
  temp_vec <- rep(NA,2000)
  cur_real_rank <- real.gl$history[,day_end_idx[t],1]
  for(s in c(1:2000)){
    temp_result <- cor.test(-sim_dsnl_active$x[s,t,], cur_real_rank, method = "spearman")
    temp_vec[s] <- temp_result$estimate
  }
  data.tbl$sub.type[(1:2000)+(t-1)*2000+42000] <- sub.types[2]  
  data.tbl$task.type[(1:2000)+(t-1)*2000+42000] <- task.types[t];  
  data.tbl$data.value[(1:2000)+(t-1)*2000+42000] <- temp_vec
}  

## Social aggregate
for (t in 1:length(task.types)){
  temp_vec <- rep(NA,2000)
  cur_real_rank <- real.gl$history[,day_end_idx[t],1]
  for(s in c(1:2000)){
    temp_result <- cor.test(sim_dsnl_inactive$x[s,t,], 
                            cur_real_rank, method = "spearman")
    temp_vec[s] <- temp_result$estimate
  }
  data.tbl$sub.type[(1:2000)+(t-1)*2000+42000*2] <- sub.types[3]  
  data.tbl$task.type[(1:2000)+(t-1)*2000+42000*2] <- task.types[t];  
  data.tbl$data.value[(1:2000)+(t-1)*2000+42000*2] <- temp_vec
}  

data.tbl$sub.type <- factor(data.tbl$sub.type);  
data.tbl$task.type <- factor(data.tbl$task.type);
```




```{r fig-10b-rank-correlation}
par(mar=c(3, 5, 3, 1))
cx <- 1.75  # cex for axis label text; 
# default is 1. bigger numbers make the text bigger, smaller, smaller.  
x.ttl <- ""; # blank x-axis label  
y.ttl <- "rank corr. (Glicko rank)";  
ttl <- "(b)";  
#y.lim <- c(min(data.tbl$data.value), max(data.tbl$data.value)+.5);
# y-axis limits. +2 at top to give room for legend  
y.lim <- c(-1,1.2)    
x.lim <- c(0.5, (length(task.types))) 
cols <- c('paleturquoise4', 'lightgreen', 'cornsilk')
shifts <- c(-0.25, 0, 0.25)
 
plot(x = 0, y = 0, xlim = x.lim, ylim = y.lim, xaxt='n',
     col = 'white', xlab = x.ttl,
     ylab = y.ttl, main = ttl,
     cex.main = cx*1.3, cex.axis = cx, cex.lab = cx); 
axis(side = 1, at = 1:length(task.types), labels = task.types,
     cex.axis=cx, cex.lab=cx)  # put on the x-axis labels  
grid(nx=NA, ny=NULL, col='darkgrey');  
lines(x=c(-1,100), y=c(0,0), col='darkgrey');  
for (t.id in 1:length(task.types)) {  
  for (i in 1:length(sub.types)) {  # t.id <- 1; i <- 1;   
   inds <- which(data.tbl$sub.type == sub.types[i] & 
                   data.tbl$task.type == task.types[t.id])
   boxplot(data.tbl$data.value[inds], at=t.id+shifts[i],
           col=cols[i], add=TRUE, 
           xaxt='n', yaxt='n', bty='n', boxwex=0.35,
           outpch = 20, outcex = 0.5) 
  }  
}  
legend(x='top', legend = sub.types, fill=cols,
       horiz = TRUE, cex = cx, bg = 'white', bty = 'n')  
box()
```

