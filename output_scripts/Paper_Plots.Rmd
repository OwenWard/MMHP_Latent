---
title: "Plots for Latent Hawkes Paper"
author: "Owen G. Ward"
date: '`r Sys.Date()`'
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: FALSE
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.path = "paper_figure/",
                      dev = 'png', fig.height = 4.5, fig.width = 7,
                      warning = FALSE)

slides_plots <- FALSE
current_cohort <- 5
```

```{r load_packages, include=FALSE}

# don't write to this path
data_path <- "../output/"

func_dir <- "../lib/"


library(rstan)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
options(mc.cores = parallel::detectCores())
library(tidyverse)
library(R.utils)
library(RColorBrewer)
library(fields)
library(bayesplot)
library(viridis)
library(compete)
library(colorspace)
source(paste(func_dir,'naiveRankHierarchy.R',sep = ""))
source(paste(func_dir,'expertRankHierarchy.R',sep = ""))
source(paste(func_dir,'cleanData.R',sep = "")) 
source(paste(func_dir,'prepareDataStan.R',sep = "")) 
source(paste(func_dir,'inferLatentMmhp.R',sep = ""))
source(paste(func_dir,'plotUtil.R',sep = "")) 
source(paste(func_dir,'mmhp.R',sep = ""))
source(paste(func_dir,'uniHawkes.R',sep = ""))
source(paste(func_dir,'simulatePrediction.R',sep = ""))
source(paste(func_dir,'myGlicko.R',sep = ""))
source(paste(func_dir,'matrixPlotParameter.R',sep = ""))
source(paste(func_dir,'residualStructureScore.R',sep = ""))
source(paste(func_dir,'drawIntensity.R',sep =""))
source("https://gist.githubusercontent.com/jalapic/6ca3ece44bdcdc522bb735f183aa0ca0/raw/1a07f469eff08117121b6cbebcd22fb7569e3ee8/compete_extra.R")


```



```{r load rankings,echo=FALSE,include=FALSE,results='hide',cache=TRUE}
full_data <- readRDS("../data/mice.RData")
# A=c9, B=c10, C=c12, D=c15, E=c16, F=c17, G=c18, H=c37, I=c38. J=c45
cohort_names <- paste("cohort",c(9,10,12,15,16,17,18,37,38,45),sep='')
cohort_short_names <- paste("C",c(9,10,12,15,16,17,18,37,38,45),sep='')
cut_off <- 3
mice_number <- 12

# Define the cohorts will be fitted
fit_cohorts <- c(1:10)
naive_rank_10 <- list()
expert_rank_10 <- list()
out <- captureOutput(for(curr_cohort in fit_cohorts){
  naive_rank_10[[curr_cohort]] <- naiveRankHierarchy(full_data[[cohort_names[curr_cohort]]])
  expert_rank_10[[curr_cohort]] <- expertRankHierarchy(full_data[[cohort_names[curr_cohort]]])
})


```

```{r define_functions}
model1_fn <- list(alpha.fun = function(x,y,eta1,eta2,eta3){return(eta1*x*y*exp(-eta2*abs(x-y))/(1 +
                                                        exp(-eta3*(x-y))))})

model3_fn <- list(alpha.fun = function(x,y,eta1,eta2){return(eta1*x*y*exp(-eta2*abs(x-y)))},
                  q1.fun = function(x,y,eta3){return(exp(-eta3*x))},
                  q0.fun = function(x,y,eta3){return(exp(-eta3*y))})


```



<!-- The aim of this notebook is a way to quickly and efficiently create all the plots -->
<!-- required for this paper. They will be built with the current fits and models. -->



# Figure 2: Contour Plot and C-HP Diagnostics

This is not effected by the final model.

## Figure 2a: Contour Plot

```{r fig-2a-contour-plot}
current_cohort <- 5
#png(paste(plot_path,"contour.png",sep=""),width=480,height=480)
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_hp$eta_1)
eta2_mean <- mean(sim_cohort_hp$eta_2)
eta3_mean <- mean(sim_cohort_hp$eta_3)
z.func <- function(x,y){
  return(x*y*eta1_mean*exp(-eta2_mean*abs(x-y))/(1+exp(-eta3_mean*(y-x))))
  # this is because axes are flipped that we have y-x in last term
  #return(x*y*eta1_mean/(1+exp(eta2_mean*abs(x-y)-eta3_mean*(y-x))))
}
z_plot <- outer(seq(1,0,-0.01),  
                seq(0,1,0.01), 
                z.func)
my.image.plot(seq(0,1,0.01), seq(0,1,0.01), z_plot,
              xlab=expression(f[j]),ylab=expression(f[i]),
              my.main="(a)", cex.main=2.3, 
              cex.lab=2.5, xLabels=c(1,0), yLabels=c(0,1))

```


## Fig 2b: C-HP Diagnostics

<!-- This is using the correct form of the compensator for a Hawkes process. -->


```{r fig-2b-diag-plot,echo=FALSE,warning=FALSE}
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_hp$eta_1)
eta2_mean <- mean(sim_cohort_hp$eta_2)
eta3_mean <- mean(sim_cohort_hp$eta_3)
f_est <- apply(sim_cohort_hp$f,2,mean)
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("observe.id","observe.time")])

ks.stat.matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
n_matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
Lambda_matrix <- matrix(list(),nrow=mice_number,ncol=mice_number)
for(k in 1:mice_number){
  for(l in c(1:mice_number)[-k]){
    i<-expert_rank_10[[current_cohort]][k]
    j<-expert_rank_10[[current_cohort]][l]
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0){
      param_mean <- list(lambda0=mean(sim_cohort_hp$lambda0),
                         alpha=model1_fn$alpha.fun(f_est[i],
                                                   f_est[j],
                                                   eta1_mean,
                                                   eta2_mean,
                                                   eta3_mean),
                         beta=mean(sim_cohort_hp$beta))
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_Lambda <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ ## check length > 2
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                          return_df$recipient == j &
                            return_df$observe.id==cur_win,"event.times"][[1]]
        current_obs_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                            return_df$observe.id==cur_win,"observe.time"]
        Lambda_vec <- uniHawkesCompensator(object = param_mean,
                              events = c(current_event_time,
                                         current_obs_time))
        all_Lambda <- c(all_Lambda,Lambda_vec)
        n_matrix[i,j] <- n_matrix[i,j] + length(current_event_time)
      }
      if(length(all_Lambda)>0){
        ks.stat.matrix[i,j] <-  ks.test(all_Lambda,"pexp",
                                        rate = 1/mean(all_Lambda))$statistic
        Lambda_matrix[i,j][[1]] <- all_Lambda
      }
    }
  }
}

# png(paste(plot_path,"/diagonsis_model1_",cohort_names[current_cohort],".png",sep=''),
#     width=480,height=480)
# -------------- KS plot (stat)
col.vec <- cRamp(as.vector(ks.stat.matrix))
## need to do some sort of transformation between these here
vir_cols <- viridis::viridis(length((as.vector(ks.stat.matrix))))
#order(as.vector(ks.stat.matrix),method = "")

values <- as.vector(ks.stat.matrix)
sorted_vals <- sort(ks.stat.matrix)
#match(values,sorted_vals)
col.vec.vir <- vir_cols[match(values,sorted_vals)]

####
par(oma = c(6,4,4,1), mar=rep(0,4),
    mgp = c(0, .2, 0))
layout(cbind(matrix(data=c(1:(12*12)), nrow = 12, ncol = 12, 
                    byrow = TRUE),rep(12*12+1,12)), 
       widths=c(rep(1,12),2), heights=rep(1,12))
for(i in expert_rank_10[[current_cohort]]){
  for(j in expert_rank_10[[current_cohort]]){
    if(ks.stat.matrix[i,j]==0){
      plot(0,0,xlim=c(0,5),ylim=c(0,5),type="n", xlab="", ylab="", 
           axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4],
           border = 0, col = 'white')
    }else{
      Lambda.test <- Lambda_matrix[i,j][[1]]
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4], 
           border = 0, col = col.vec.vir[matrixToVecIdx(i,j,mice_number)])
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE,add=TRUE, lwd=2)
      plot(ecdf(Lambda.test), add = TRUE, do.points = FALSE,
           verticals = TRUE, col = "red", lwd = 2)
    }
  }
}
par(mar = c(0,2,0,3),mgp=c(0,0.8,0))
m1_ks <- ks.stat.matrix
col_obj <- list(x.vec = seq(0,max(as.vector(ks.stat.matrix)),length.out = 100),
                col.vec = viridis(100))

temp <- cLegend(as.vector(ks.stat.matrix))
#which(temp$x.vec == as.vector(ks.stat.matrix))
## need to adjust this for the legend also.
# image(1, cLegend(as.vector(ks.stat.matrix))$x.vec,
#       matrix(data=cLegend(as.vector(ks.stat.matrix))$x.vec, 
#              ncol=length(cLegend(as.vector(ks.stat.matrix))$x.vec),nrow=1),
#       col=cLegend(as.vector(ks.stat.matrix))$col.vec,
#       xlab="",ylab="",axes=FALSE)
image(1, col_obj$x.vec,
      matrix(data=col_obj$x.vec, 
             ncol=length(col_obj$x.vec),nrow=1),
      col=col_obj$col.vec,
      xlab="",ylab="", axes = FALSE)
axis(4, at=c(0,0.3,0.6), labels=c(0,0.3,0.6), las= HORIZONTAL<-1,
     cex.axis=2.4)

mtext(text=expert_rank_10[[current_cohort]], side=1, line=1.8, outer=TRUE, cex=1.8,
      at=1/14*c(1:12)-1/22)
mtext(text = expert_rank_10[[current_cohort]],
      side = 2, line = 0.5, outer = TRUE, cex = 1.8,
      at =1/12*c(12:1)-1/20, las = 2)
mtext(text = "(b)", side = 3, line = 1.4, outer = TRUE,
      cex = 2.2,
      at=0.45, font=2)
#dev.off()
```

# Figure 3: Comparison of C-HP and C-DCHP

## Figure 3a: Baseline rates


```{r fig-3a-baseline-rate}
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
gamma_mean <- apply(sim_cohort_dchp$gamma,2,mean)
zeta_mean <- apply(sim_cohort_dchp$zeta,2,mean)

# social matrix plot
latent_social_matrix <- gamma_mean %*%
  t(rep(1,mice_number)) + rep(1,mice_number) %*% t(zeta_mean)

# png(paste(plot_path,"/lambda0_",
# cohort_names[current_cohort],".png",sep=''),
#     width=400, height=300)
matrixPlotParameter(latent_social_matrix[
  rev(expert_rank_10[[current_cohort]]),
                                         expert_rank_10[[current_cohort]]],
                    xLabels=expert_rank_10[[current_cohort]],
                    yLabels=rev(expert_rank_10[[current_cohort]]) )
                    # title = "(a)" )
# mtext(text=c(1,2,11,6,7,9), side=1, line=-0.35, outer=TRUE, cex=1.3,
#       at=1/17.8*seq(2,12,2)+0.09)
#dev.off()
```
## Figure 3b: Ranking Comparison

```{r fig-3b-rank-comparison}
# current_cohort <- 5

colors_plot <- viridis(2)
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
# png(paste(plot_path,"/rank_",cohort_names[current_cohort],".png",sep=''),
#     width=400, height=300)
par(oma = c(0,0,2,0), mar = c(3,4,1,1),mgp=c(0,0.5,0))
plot(order(expert_rank_10[[current_cohort]]),
     apply(sim_cohort_hp$f,2,mean),pch=16,cex=1.2,
     #col= "steelblue",
     col = colors_plot[1],
     ylab="",xlab="",
     xlim=c(1,12.5),ylim=c(0,1), xaxt="n", yaxt="n")
segments(order(expert_rank_10[[current_cohort]]),
         apply(sim_cohort_hp$f,2,mean)-apply(sim_cohort_hp$f,2,sd),
         order(expert_rank_10[[current_cohort]]),
         apply(sim_cohort_hp$f,2,mean)+apply(sim_cohort_hp$f,2,sd),
         #col= add.alpha("steelblue",0.8),lwd=2)
         col = add.alpha(colors_plot[1],0.8), lwd =2)
points(order(expert_rank_10[[current_cohort]])+0.2,
       apply(sim_cohort_dchp$f,2,mean),
       pch=16,cex=1.2,
       col=colors_plot[2])
       #col="goldenrod2")
segments(order(expert_rank_10[[current_cohort]])+0.2,
         apply(sim_cohort_dchp$f,2,mean)-apply(sim_cohort_dchp$f,2,sd),
         order(expert_rank_10[[current_cohort]])+0.2,
         apply(sim_cohort_dchp$f,2,mean)+apply(sim_cohort_dchp$f,2,sd),
         col= add.alpha(colors_plot[2],0.8),lwd=2)
         #col= add.alpha("goldenrod2",0.8),lwd=2)

axis(BELOW<-1, at=1:12, labels=expert_rank_10[[current_cohort]], cex.axis=1.3, tck=-0.015)
#mtext(text=11, side=1, line=0.5, cex=1.3, at=6)

axis(LEFT <-2, at=seq(0,1,0.2), labels=seq(0,1,0.2), las= HORIZONTAL<-1,
     cex.axis=1.3, tck=-0.015)
mtext(side=1, text="I&SI rank", line=1.8, cex=1.5)
mtext(side=2, text="Latent rank", line=2.4, cex=1.6)
mtext(side=3, text="(b)", line=0.8, cex=1.6, font=2)
legend('bottomleft', legend = c("C-HP", "C-DCHP"),
       pch = c(16, 16), lty = c(1, 1), lwd=c(2,2),
       #col=c("steelblue","goldenrod"),
       col=c(colors_plot[1],colors_plot[2]),
       cex=1.5)
#dev.off()
```


```{r, eval=FALSE}
par(mar=c(3,3,1,1))
plot(as.vector(n_matrix[n_matrix>0]), as.vector(ks.stat.matrix[n_matrix>0]),
     xlab="", ylab="", pch=16, col="gray", cex= 0.8, xaxt="n", yaxt="n",
     ylim=c(0,0.65))
mtext("Number of events", cex=1.5, side=1, line=1.8)
mtext("K-S statistics", cex=1.5, side=2, line=1.5)
mgp.axis(1,mgp=c(0,0.3,0),at=seq(0,120,10),cex.axis=1,lwd=0,lwd.ticks=0.1)
mgp.axis(2,mgp=c(0,0.1,0),at=seq(-0.2,0.6,0.2),cex.axis=1,lwd=0,lwd.ticks=0.8)
```

# Redone Figure 3

As discussed, it would be interesting to redo figure 3b
to show the lack of fit in model 2 for one specific pair. This can be somewhat
extracted from the diagnostics file.


We actually want the empirical CDF plot here.



```{r fig_3b_update, fig.height=7}
# 2 -> 11 might be good here
# current_cohort <- 5
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
            observe=list(observe.id),
            observe.length=list(observe.time),
            no.events=list(no.events)) 
top_pairs <- unique_pairs_df %>% arrange(desc(count))

best_i <- top_pairs$initiator[8]
best_j <- top_pairs$recipient[8]

current_i <- best_i #8
current_j <- best_j #2

### then plots ####
# par(mfrow = c(1, 2), oma = c(1, 1, 1, 1),
#      mar = c(2, 3, 2, 1), mgp = c(0.8,0,0))
# layout(matrix(1:8,nrow=2,byrow=TRUE),widths=rep(2,4),height=c(3,3))
anno.cex <- 1.3
title.cex <- 2.2
title.line <- 0.5
y.upper <- 20
#### then the corresponding QQ plot ####
load(paste(data_path,cohort_names[current_cohort],
             "/real_diag_four_models_",cohort_names[current_cohort],
             ".RData",sep=''))
Lambda.dc_hawkes.test <- Lambda_dc_hawkes_matrix[current_i,current_j][[1]]

p <- ppoints(length(Lambda.dc_hawkes.test))
# 100 equally spaced points on (0,1), excluding endpoints
q <- quantile(Lambda.dc_hawkes.test,p=p,na.rm=TRUE)
# percentiles of the sample distribution
plot(qexp(p),q,
     xlab="",ylab="",xaxt="n",yaxt="n",
     pch=1, cex=1, col=viridis::viridis(1), ylim=c(0,1), xlim=c(0,4.5))
mtext(side = 1, text = "Theoretical", line=1.6, cex=anno.cex)
mtext(side = 2, text = "Empirical", line = 1.2, cex = anno.cex)
mtext(side = 3, text = "(b)", line = 0.8, cex = 1.6, font = 2)
# Hmisc::mgp.axis(1,mgp=c(0,0.1,0),at=c(0:5),cex.axis=1,lwd=0,lwd.ticks=1)
# Hmisc::mgp.axis(2,mgp=c(0,0.1,0),at=c(0:1),cex.axis=1,lwd=0,lwd.ticks=1)
qqline(q, distribution=qexp,col="Black", lty=1, lwd=2.5)

### Empirical CDF ####

plot(ecdf(Lambda.dc_hawkes.test), do.points = FALSE,
     verticals = TRUE, col = viridis::viridis(1), lwd = 2, 
     xlab = "", ylab = "", xaxt = "n", yaxt = "n",
     main = "", col.01line = NULL)
curve(pexp(x,1/mean(Lambda.dc_hawkes.test)),
      min(Lambda.dc_hawkes.test), max(Lambda.dc_hawkes.test),
      ylab = "", xlab = "",
      add = TRUE, lwd = 2)

```

```{r repeat entire fig2b for model 2}
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
             "/real_diag_four_models_",cohort_names[current_cohort],
             ".RData",sep=''))

load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_dchp$eta_1)
eta2_mean <- mean(sim_cohort_dchp$eta_2)
eta3_mean <- mean(sim_cohort_dchp$eta_3)
f_est <- apply(sim_cohort_dchp$f,2,mean)
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("observe.id","observe.time")])

ks.stat.matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
n_matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
Lambda_matrix <- matrix(list(),nrow=mice_number,ncol=mice_number)
for(k in 1:mice_number){
  for(l in c(1:mice_number)[-k]){
    i<-expert_rank_10[[current_cohort]][k]
    j<-expert_rank_10[[current_cohort]][l]
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0){
      param_mean <- list(lambda0=mean(sim_cohort_dchp$lambda0[,pair]),
                         alpha=model1_fn$alpha.fun(f_est[i],
                                                   f_est[j],
                                                   eta1_mean,
                                                   eta2_mean,
                                                   eta3_mean),
                         beta=mean(sim_cohort_dchp$beta))
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_Lambda <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ ## check length > 2
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                          return_df$recipient == j &
                            return_df$observe.id==cur_win,"event.times"][[1]]
        current_obs_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                            return_df$observe.id==cur_win,"observe.time"]
        Lambda_vec <- uniHawkesCompensator(object = param_mean,
                              events = c(current_event_time,
                                         current_obs_time))
        all_Lambda <- c(all_Lambda,Lambda_vec)
        n_matrix[i,j] <- n_matrix[i,j] + length(current_event_time)
      }
      if(length(all_Lambda)>0){
        ks.stat.matrix[i,j] <-  ks.test(all_Lambda,"pexp",
                                        rate = 1/mean(all_Lambda))$statistic
        Lambda_matrix[i,j][[1]] <- all_Lambda
      }
    }
  }
}

m2_ks <- ks.stat.matrix

# -------------- KS plot (stat)
col.vec <- cRamp(as.vector(ks.stat.matrix))
## need to do some sort of transformation between these here
vir_cols <- viridis::viridis(length((as.vector(ks.stat.matrix))))
#order(as.vector(ks.stat.matrix),method = "")

values <- as.vector(ks.stat.matrix)
sorted_vals <- sort(ks.stat.matrix)
#match(values,sorted_vals)
col.vec.vir <- vir_cols[match(values,sorted_vals)]

####
par(oma = c(6,4,4,1), mar=rep(0,4),
    mgp = c(0, .2, 0))
layout(cbind(matrix(data=c(1:(12*12)), nrow = 12, ncol = 12, 
                    byrow = TRUE),rep(12*12+1,12)), 
       widths=c(rep(1,12),2), heights=rep(1,12))
for(i in expert_rank_10[[current_cohort]]){
  for(j in expert_rank_10[[current_cohort]]){
    if(ks.stat.matrix[i,j]==0){
      plot(0,0,xlim=c(0,5),ylim=c(0,5),type="n", xlab="", ylab="", 
           axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4],
           border = 0, col = 'white')
    }else{
      Lambda.test <- Lambda_matrix[i,j][[1]]
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4], 
           border = 0, col = col.vec.vir[matrixToVecIdx(i,j,mice_number)])
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE,add=TRUE, lwd=2)
      plot(ecdf(Lambda.test), add = TRUE, do.points = FALSE,
           verticals = TRUE, col = "red", lwd = 2)
    }
  }
}
par(mar = c(0,2,0,3),mgp=c(0,0.8,0))

col_obj <- list(x.vec = seq(0,max(as.vector(ks.stat.matrix)),
                            length.out = 100),
                col.vec = viridis(100))

temp <- cLegend(as.vector(ks.stat.matrix))

image(1, col_obj$x.vec,
      matrix(data=col_obj$x.vec, 
             ncol=length(col_obj$x.vec),nrow=1),
      col=col_obj$col.vec,
      xlab="",ylab="",axes=FALSE)
axis(4, at=c(0,0.3,0.6), labels=c(0,0.3,0.6), las= HORIZONTAL<-1,
     cex.axis=2.4)

mtext(text=expert_rank_10[[current_cohort]], side=1,
      line=1.8, outer=TRUE, cex=1.8,
      at=1/14*c(1:12)-1/22)
mtext(text = expert_rank_10[[current_cohort]],
      side = 2, line = 0.5, outer = TRUE, cex = 1.8,
      at =1/12*c(12:1)-1/20, las = 2)
mtext(text = "(b)", side = 3, line = 1.4, outer = TRUE,
      cex = 2.2,
      at=0.45, font=2)

```

```{r construct ks_diff}
ks_diff <-  (m2_ks - m1_ks)/m1_ks
ks_diff[is.nan(ks_diff)] <- 0
# -------------- KS plot (stat)
col.vec <- cRamp(as.vector(ks_diff))
## need to do some sort of transformation between these here
vir_cols <- viridis::viridis(length((as.vector(ks_diff))))
#order(as.vector(ks.stat.matrix),method = "")

values <- as.vector(ks_diff)
sorted_vals <- sort(ks_diff)
#match(values,sorted_vals)
col.vec.vir <- vir_cols[match(values,sorted_vals)]

####
par(oma = c(6,4,4,1), mar=rep(0,4),
    mgp = c(0, .2, 0))
layout(cbind(matrix(data=c(1:(12*12)), nrow = 12, ncol = 12, 
                    byrow = TRUE),rep(12*12+1,12)), 
       widths=c(rep(1,12),2), heights=rep(1,12))
for(i in expert_rank_10[[current_cohort]]){
  for(j in expert_rank_10[[current_cohort]]){
    if(ks_diff[i,j]==0){
      plot(0,0,xlim=c(0,5),ylim=c(0,5),type="n", xlab="", ylab="", 
           axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4],
           border = 0, col = 'white')
    }else{
      Lambda.test <- Lambda_matrix[i,j][[1]]
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4],
           border = 0, col = col.vec.vir[matrixToVecIdx(i,j,mice_number)])

    }
  }
}
par(mar = c(0,2,0,3),mgp=c(0,0.8,0))

col_obj <- list(x.vec = seq(min(as.vector(ks_diff)),max(as.vector(ks_diff)),
                            length.out = 100),
                col.vec = viridis(100))

# temp <- cLegend(as.vector(ks_diff))

image(1, col_obj$x.vec,
      matrix(data=col_obj$x.vec, 
             ncol=length(col_obj$x.vec),nrow=1),
      col=col_obj$col.vec,
      xlab="",ylab="")
# axis(4, at=c(-0.2,0,0.2), labels=c(-0.2,0,0.2), las= HORIZONTAL<-1,
#      cex.axis=2.4)

mtext(text=expert_rank_10[[current_cohort]], side=1,
      line=1.8, outer=TRUE, cex=1.8,
      at=1/14*c(1:12)-1/22)
mtext(text = expert_rank_10[[current_cohort]],
      side = 2, line = 0.5, outer = TRUE, cex = 1.8,
      at =1/12*c(12:1)-1/20, las = 2)
mtext(text = "(M2 - M1)/M1", side = 3, line = 1.4, outer = TRUE,
      cex = 2.2,
      at=0.45, font=2)

```

```{r construct ks diff normalised by num events}
norm_diff <- (m2_ks - m1_ks)#/m1_ks
norm_diff[is.nan(norm_diff)] <- 0
count_mat <- matrix(0, nrow = mice_number, ncol = mice_number)

for(i in expert_rank_10[[current_cohort]]) {
  for(j in expert_rank_10[[current_cohort]]) {
    if( norm_diff[i,j] != 0 ) {
      num_events <- unique_pairs_df %>% 
      filter(initiator == i & recipient == j) %>%
      pull(count)
      # diff[i,j] <- diff[i,j] / num_events
      count_mat[i,j] <- num_events
    }
  }
}


tibble(diff_norm = as.vector(norm_diff),
       events = as.vector(count_mat)) %>%
  filter(events > 0 ) %>%
  ggplot(aes(events,diff_norm)) + geom_point() +
  ylab("M2-M1") +
  theme_minimal()

tibble(diff_norm = as.vector(norm_diff),
       events = as.vector(count_mat)) %>%
  filter(events > 0) %>%
  ggplot(aes(diff_norm)) + 
  geom_histogram() +
  theme_minimal()

```
```{r repeat for residuals}
m1_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                   "/chp_pr_matrix_",cohort_names[current_cohort],
                   ".RDS",sep=''))

m2_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/dchp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

tibble(m1pr = as.vector(m1_pr),
       m2pr = as.vector(m2_pr)) %>%
  mutate(diff = m2pr - m1pr) %>%
  ggplot(aes(diff)) + 
  geom_histogram() +
  labs(x = "M2 PR - M1 PR") +
  theme_minimal()

```

```{r compute mean decrease in ks-score}
summary(as.vector(m2_ks[m2_ks != 0]))
summary(as.vector(m1_ks[m1_ks != 0]))

t.test(as.vector(m2_ks[m2_ks != 0]), as.vector(m1_ks[m1_ks != 0]))

diff <- as.vector(m2_ks[m2_ks != 0]) - as.vector(m1_ks[m1_ks != 0])

length(which(diff < 0))/length(diff)
summary(diff)
```


This is good because it shows the most active animal, shows that individual
out rate too large for this interaction. Just need to make this more
like the plots in 2b.


# Figure 4:

## Figure 4a Recover Latent Ranks
```{r fig-4a}
sim_data_path <- "../output/sims/sims_m3_dc/"


load(paste(sim_data_path,"sim_model3_fit123.RData",sep=''))
load(paste(sim_data_path,"fit123_state_est.RData",sep=''))


n_sim <- 50

#png(paste(plot_path,"sim_latent_recover.png",sep=""), height=500, width=900)
par(mfrow=c(3, length(object_par$f_vec_1)),
    mar=c(0,0,1,0),
    oma=c(6.5,11,3.5,1))

y.ub <- c(12,12,12,12,12)
text.y <- c(rep(8,4),8)
text.x <- c(0.1,0.2,0.4,0.7,0.9)
text.x.adj <- c(0.3,0.4,0.6,0.5,0.8)
model_colors <- c("steelblue", "goldenrod2", "firebrick2")
model_colors <- viridis::viridis(3)

for(m in c(1:3)){
  for(j in c(1:length(object_par$f_vec_1))){
    plot(1,4,xlim=c(0,1),ylim=c(0,y.ub[j]),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    
    ## Posterior density
    current_result <- eval(parse(text=paste("sim_model3_stan_sim",m,sep="")))
    for(i in c(1:n_sim)){
      lines(density(current_result[[i]]$f[1001:2000,j]),
            col=add.alpha(model_colors[m], alpha=0.8),cex=0.6,lwd=0.8)
    }
    
    ## plot true value
    abline(v=object_par$f_vec_1[j],lwd=1.8,lty=2,col="gray30")
    
    ## plot box
    box.wdt <- 1.5
    box.col <- "black"
    box(lty = 'solid',col=box.col,lwd=0.7)
    
    if(m==3){
      text(text.x.adj[j],text.y[j],text.x[j],cex=2.4)
    }
  }
  ## bottom
  mtext(text=expression(f[1],f[2],f[3],f[4],f[5]), side=1, line=2.4, outer=TRUE, 
        at=c(1:length(object_par$f_vec_1))/length(object_par$f_vec_1)-0.1,
        cex=2.4)
  mtext(text="Latent rank variables", side=1, line=5.3, outer=TRUE, cex=2.7,
        at=0.5)
  ## top
  mtext(text="(a)", side=3, line=0, outer=TRUE, cex=3,
        at=0.5, font=2)
  ## left
  mtext(text=rev(c("C-HP  ","C-DCHP","C-MMHP")), side=2, line=0.5, outer=TRUE, 
        at=c(0:2)/3+0.15,
        cex=2, las=2)
}

```

## Figure 4b: Recover Latent States


```{r prepare data for 4b,cache=TRUE}
plot.s <- 1#7#9
plot.i <- 4
plot.j <- 5

cur_i <- 4
cur_j <- 5

test.mmhp <- sim_model3_data[plot.s][[1]]$mmhp_matrix[plot.i,plot.j][[1]]
temp.t <- test.mmhp$tau
current.n <- length(temp.t)-1
time.segment <- seq(0,tail(temp.t,1),length.out=5000)

### Preprocess the model inference result
## model 1
#########
model1_par_est <- list(lambda0 =
                         mean(sim_model3_stan_sim1[[plot.s]]$lambda0[1001:2000]),
                       eta_1=mean(sim_model3_stan_sim1[[plot.s]]$eta_1[1001:2000]),
                       eta_2=mean(sim_model3_stan_sim1[[plot.s]]$eta_2[1001:2000]),
                       eta_3=mean(sim_model3_stan_sim1[[plot.s]]$eta_3[1001:2000]),
                       beta=mean(sim_model3_stan_sim1[[plot.s]]$beta[1001:2000]),
                       f=apply(sim_model3_stan_sim1[[plot.s]]$f[1001:2000,],2,mean))
lambda.m1<-uniHawkesIntensityNumeric(object=list(lambda0 = 
                                                   model1_par_est$lambda0,
                                    alpha =
                                      model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                    model1_par_est$f[plot.j],
                                    model1_par_est$eta_1,
                                    model1_par_est$eta_2,
                                    model1_par_est$eta_3),
                                    beta=model1_par_est$beta),
                                     events=temp.t,
                                     time.vec=time.segment)


## model2
#############
model2_par_est <- list(gamma=apply(sim_model3_stan_sim2[[plot.s]]$gamma[1001:2000,],
                                   2,mean),
                    zeta = 
                      apply(sim_model3_stan_sim2[[plot.s]]$zeta[1001:2000,],2,mean),
                       eta_1=mean(sim_model3_stan_sim2[[plot.s]]$eta_1[1001:2000]),
                       eta_2=mean(sim_model3_stan_sim2[[plot.s]]$eta_2[1001:2000]),
                       eta_3=mean(sim_model3_stan_sim2[[plot.s]]$eta_3[1001:2000]),
                       beta=mean(sim_model3_stan_sim2[[plot.s]]$beta[1001:2000]),
                       f=apply(sim_model3_stan_sim2[[plot.s]]$f[1001:2000,],2,mean))

lambda.m2 <- uniHawkesIntensityNumeric(object=list(
  lambda0=model2_par_est$gamma[plot.i]+
          model2_par_est$zeta[plot.j],                                        
  alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                            model2_par_est$f[plot.j],
                            model2_par_est$eta_1,
                            model2_par_est$eta_2,
                            model2_par_est$eta_3),
                beta=model2_par_est$beta),
                events=temp.t,
                time.vec=time.segment)

## Model3
#############
mmhp_par_est <- list(lambda0=mean(sim_model3_stan_sim3[[plot.s]]$lambda0[1001:2000]),
                     lambda1=mean(sim_model3_stan_sim3[[plot.s]]$lambda1[1001:2000]),
                     eta_1=mean(sim_model3_stan_sim3[[plot.s]]$eta_1[1001:2000]),
                     eta_2=mean(sim_model3_stan_sim3[[plot.s]]$eta_2[1001:2000]),
                     eta_3=mean(sim_model3_stan_sim3[[plot.s]]$eta_3[1001:2000]),
                     beta=mean(sim_model3_stan_sim3[[plot.s]]$beta[1001:2000]),
                     f=apply(sim_model3_stan_sim3[[plot.s]]$f[1001:2000,],2,mean))

object_hat <- list(lambda0=mmhp_par_est$lambda0,
                   lambda1=mmhp_par_est$lambda1,
                   alpha=model3_fn$alpha.fun(mmhp_par_est$f[cur_i],
                                             mmhp_par_est$f[cur_j],
                                             mmhp_par_est$eta_1,
                                             mmhp_par_est$eta_2),
                   beta=mmhp_par_est$beta,
                   q1=model3_fn$q1.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3),
                   q2=model3_fn$q0.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3))


state.est.latent.mmhp <- interpolate_state_est_lst[[plot.s]][plot.i,plot.j][[1]]
state.est.latent.mmhp.new <- fixInterpolateState(state.est.latent.mmhp,
                                                 termination=200)

step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,
                        2-state.est.latent.mmhp$z.hat)

lambda.m3 <- mmhpIntensityNumeric(params=object_hat,
                                  t=temp.t[-1],
                                  time.vec=time.segment,
                                  latent.vec=step.fun.est(time.segment))

object_true <- lapply(object_matrix,function(x) x[plot.i,plot.j])
names(object_true) <- c("lambda0","lambda1","alpha","beta","q1","q2")

lambda.true <- mmhpTrueIntensityNumeric(params=object_true,
                                        t=temp.t,
                       latent=list(x=fixStateTransition(test.mmhp)$x,
                              z=fixStateTransition(test.mmhp)$z),
                              time.vec=time.segment)

```


```{r fig4b-recover-latent-states}
y.ub <- c(17,17,17)#c(130,72,31)
x_events <- 135#150
#model_colors <- c("steelblue", "goldenrod2", "firebrick2")
model_colors <- viridis::viridis(3)
layout(matrix(c(1:6), 6, 1), heights=rep(c(2.5,1),3))
layout(matrix(c(1:6), 6, 1), heights=rep(c(7.5,1),3))
my.xlim <- 140#160#200#130
my.long.x <- 140#205#134.5
legend.x <- c(50,50,50)#c(135,135,135)
legend.y <- #c(34,32,32)
legend.y <- c(15,12,15)#c(62,37,18)#c(22,22,22)
legend.cex <- 1.5 #3
line.alpha <- c(0.9,0.6)
line.wdth <- c(2,2.5)
negative.col <- add.alpha('lightskyblue',0.6)
positive.col <- add.alpha('tomato',0.6)
#negative.col <- viridis::viridis(5,alpha = 0.6)[1]
#positive.col <- viridis::viridis(5,alpha = 0.6)[4]
par(mar = c(0,0.3,0,0.1), oma = c(3,3.5,4,0),
    tcl=0.2,mgp=c(0.5,0,0), xpd=TRUE)

# model1
############
true.object <- object_true

drawUniMMHPIntensityPaper(true.object,simulation=fixStateTransition(test.mmhp),
                          yupper=y.ub[1], 
                          color=add.alpha("black", alpha=line.alpha[1]),
                          line.width=line.wdth[1],
                          y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim,
                          title_name=paste(plot.i,"->",plot.j),
                          title.cex = 2,
                          box.type="n")
drawHawkesIntensityPaper(lambda0=model1_par_est$lambda0,
                         alpha=model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                                   model1_par_est$f[plot.j],
                                                   model1_par_est$eta_1,
                                                   model1_par_est$eta_2,
                                                   model1_par_est$eta_3),
                         beta=model1_par_est$beta,
                         events=test.mmhp$tau,
                         color=add.alpha(model_colors[1],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])

## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)


## add legend
# changed 34 to 23, 25 to 18, -20 to -10
# legend(10,legend.y[1],c("State 1/0 events","State change point"),
#        col = c(NA,"red"),
#        y.intersp=0.85,x.intersp=-0.1, bty = "n",
#        pch = c(NA,4), pt.cex = c(NA,2), cex=legend.cex,
#        lty = c(NA,NA), lwd=c(NA,4))
# points(29,84,pch=1,cex=2,col="blue")
# points(26,84,pch=16,cex=2,col="blue")
legend(legend.x[1],legend.y[1],c("True"),
       col = c("black"),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)
legend(legend.x[1]+18,legend.y[1],c("C-HP"),
       col = c(model_colors[1]),
       y.intersp=0.88,x.intersp=0.15,bty = "n",
       lty = c(1), lwd = c(5), cex=legend.cex,seg.len=1)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-4,10), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m1$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now ###
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events),#200
        c(0,delta.positive,0),col=positive.col,border=NA)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model2
############
drawUniMMHPIntensityPaper(true.object,simulation=fixStateTransition(test.mmhp),
                          yupper=y.ub[2], 
                          color=add.alpha("black", alpha=line.alpha[1]),
                          line.width=line.wdth[1],
                          y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim, 
                          box.type="n")
drawHawkesIntensityPaper(lambda0=model2_par_est$gamma[plot.i]+
                           model2_par_est$zeta[plot.j],
                         alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                                                   model2_par_est$f[plot.j],
                                                   model2_par_est$eta_1,
                                                   model2_par_est$eta_2,
                                                   model2_par_est$eta_3),
                         beta=model2_par_est$beta,
                         events=test.mmhp$tau,
                         color=add.alpha(model_colors[2],
                                         alpha=line.alpha[2]),
                         line.width=line.wdth[2])
legend(legend.x[2],legend.y[2],"C-DCHP",
       col = model_colors[2],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty = 1, lwd = 5, cex= legend.cex,seg.len=1)

axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(10,legend.y[2]+2,c("State 0/1 events","State change point"),
       col = c(NA,"red"),
       y.intersp=0.85,x.intersp=-0.1, bty = "n",
       pch = c(NA,4), pt.cex = c(NA,2), cex=legend.cex,
       lty = c(NA,NA), lwd=c(NA,4))
points(14,8+2,pch=1,cex=2,col="blue")
points(16,8+2,pch=16,cex=2,col="blue")

## delta lambda
par(mar = c(0,0.3,0,0.1))
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t

plot(lambda.true$time.vec,delta.lambda,xlim=c(0,my.xlim), ylim=c(-3,10), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m2$lambda.t-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), #200
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


# model3
########
par(mar = c(0,0.3,1,0.1))
drawUniMMHPIntensityPaper(true.object,
                          simulation=fixStateTransition(test.mmhp),
                          yupper=y.ub[3],
                          color=add.alpha("black", alpha=line.alpha[1]),
                          line.width=line.wdth[1],
                          y.ratio=-0.05, min.y=-2, min.x=0, max.x=my.xlim, 
                          box.type="n")
drawUniMMHPIntensityPaper(object_hat,
                          simulation = list(
  x=state.est.latent.mmhp.new$x.hat,                                          
  z=state.est.latent.mmhp.new$z.hat,
  tau=test.mmhp$tau,zt=test.mmhp$zt,
  lambda.max=test.mmhp$lambda.max),
                          yupper=y.ub,add=TRUE,
                          color=add.alpha(model_colors[3],
                                      alpha=line.alpha[2]),
  line.width=line.wdth[2])
legend(legend.x[3],legend.y[3],"C-MMHP",
       col = model_colors[3],
       y.intersp=0.88,x.intersp=0.1,bty = "n",
       lty =1, lwd = 5,cex=legend.cex,seg.len=1)
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0.5,tick=T,labels=rep("",2),lwd=0.5,lwd.ticks=0,lty=3)

legend(10,legend.y[3],c("Overestimation","Underestimation"),
       col = c(positive.col,negative.col),
       y.intersp=0.88,x.intersp=0.5,bty = "n",
       lty = c(1,1), lwd = c(10,10), cex=legend.cex,seg.len=0.8)

## delta lambda
par(mar = c(0,0.3,0,0.1))
plot(0,0,xlim=c(0,my.xlim), ylim=c(-12,8), type="n",
     bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
delta.lambda <- lambda.m3-lambda.true$lambda.t
delta.positive <- delta.lambda
delta.positive[delta.positive<0] <- 0
delta.negative <- delta.lambda
delta.negative[delta.negative>0] <- 0
### hiding these for now
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.negative,0),col=negative.col,border=NA)
polygon(c(0,lambda.true$time.vec,x_events), # 200 
        c(0,delta.positive,0),col=positive.col,border=NA)
# segments(0,0,my.xlim,0,col="gray45")
## draw box
axis(1,at=c(-2,my.long.x),col="gray35",
     line=0,tick=T,labels=rep("",2),lwd=0.7,lwd.ticks=0)


## top
mtext(text="(b)",side=3,line=0.8,outer=TRUE,cex=2.5,font=2)
## bottom
mtext(text="Time",side=1,line=2,outer=TRUE,cex=2.5)
## left
mtext(text="Intensity",side=2,line=0.6,outer=TRUE,cex=2.5)
```

## Fig 4 repeated for data generated from other models

For completeness, we also wish to repeat the above two plots using data generated 
from M1 and M2.

For data simulated from M1.

```{r est ranks for m1 sim data}
m1_path <- "../output/sims/M1/"

m1_files <- list.files(m1_path, pattern = "sim_model1_fit*")
#m1_files

# load(paste0(m1_path,m1_files[1]))
sim_model1_stan_sim1_total <- list()
sim_model1_stan_sim2_total <- list()
sim_model1_stan_sim3_total <- list()

for(i in seq_along(m1_files)) {
  load(paste0(m1_path,m1_files[i]))
  sim_model1_stan_sim1_total[[i]] <- sim_model1_stan_sim1
  sim_model1_stan_sim2_total[[i]] <- sim_model1_stan_sim2
  sim_model1_stan_sim3_total[[i]] <- sim_model1_stan_sim3
  
}

m2_path <- "../output/sims/M2/"

m2_files <- list.files(m2_path, pattern = "sim_model2_fit*")
#m1_files

# load(paste0(m1_path,m1_files[1]))
sim_model2_stan_sim1_total <- list()
sim_model2_stan_sim2_total <- list()
sim_model2_stan_sim3_total <- list()

for(i in seq_along(m2_files)) {
  load(paste0(m2_path,m2_files[i]))
  sim_model2_stan_sim1_total[[i]] <- sim_model2_stan_sim1
  sim_model2_stan_sim2_total[[i]] <- sim_model2_stan_sim2
  sim_model2_stan_sim3_total[[i]] <- sim_model2_stan_sim3
  
}

```


```{r plot est ranks M1 and M2}
n_sim <- 50

#png(paste(plot_path,"sim_latent_recover.png",sep=""), height=500, width=900)
par(mfrow=c(3, length(object_par$f_vec_1)),
    mar=c(0,0,1,0),
    oma=c(6.5,11,3.5,1))

y.ub <- c(12,12,12,12,12)
text.y <- c(rep(8,4),8)
text.x <- c(0.1,0.2,0.4,0.7,0.9)
text.x.adj <- c(0.3,0.4,0.6,0.5,0.8)
model_colors <- c("steelblue", "goldenrod2", "firebrick2")
model_colors <- viridis::viridis(3)

for(m in c(1:3)){
  for(j in c(1:length(object_par$f_vec_1))){
    plot(1,4,xlim=c(0,1),ylim=c(0,y.ub[j]),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    
    ## Posterior density
    current_result <- eval(parse(text=paste("sim_model1_stan_sim",
                                            m,
                                            "_total",
                                            sep="")))
    for(i in c(1:n_sim)){
      lines(density(current_result[[i]]$f[1001:2000,j]),
            col=add.alpha(model_colors[m], alpha=0.8),cex=0.6,lwd=0.8)
    }
    
    ## plot true value
    abline(v=object_par$f_vec_1[j],lwd=1.8,lty=2,col="gray30")
    
    ## plot box
    box.wdt <- 1.5
    box.col <- "black"
    box(lty = 'solid',col=box.col,lwd=0.7)
    
    if(m==3){
      text(text.x.adj[j],text.y[j],text.x[j],cex=2.4)
    }
  }
  ## bottom
  mtext(text=expression(f[1],f[2],f[3],f[4],f[5]), side=1, line=2.4, outer=TRUE, 
        at=c(1:length(object_par$f_vec_1))/length(object_par$f_vec_1)-0.1,
        cex=2.4)
  mtext(text="Latent rank variables", side=1, line=5.3, outer=TRUE, cex=2.7,
        at=0.5)
  ## top
  mtext(text="Simulated from M1", side=3, line=0, outer=TRUE, cex=3,
        at=0.5, font=2)
  ## left
  mtext(text=rev(c("C-HP  ","C-DCHP","C-MMHP")), side=2, line=0.5, outer=TRUE, 
        at=c(0:2)/3+0.15,
        cex=2, las=2)
}


for(m in c(1:3)){
  for(j in c(1:length(object_par$f_vec_1))){
    plot(1,4,xlim=c(0,1),ylim=c(0,y.ub[j]),
         type="n",xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
    
    ## Posterior density
    current_result <- eval(parse(text=paste("sim_model2_stan_sim",
                                            m,
                                            "_total",
                                            sep="")))
    for(i in c(1:n_sim)){
      lines(density(current_result[[i]]$f[1001:2000,j]),
            col=add.alpha(model_colors[m], alpha=0.8),cex=0.6,lwd=0.8)
    }
    
    ## plot true value
    abline(v=object_par$f_vec_1[j],lwd=1.8,lty=2,col="gray30")
    
    ## plot box
    box.wdt <- 1.5
    box.col <- "black"
    box(lty = 'solid',col=box.col,lwd=0.7)
    
    if(m==3){
      text(text.x.adj[j],text.y[j],text.x[j],cex=2.4)
    }
  }
  ## bottom
  mtext(text=expression(f[1],f[2],f[3],f[4],f[5]), side=1, line=2.4, outer=TRUE, 
        at=c(1:length(object_par$f_vec_1))/length(object_par$f_vec_1)-0.1,
        cex=2.4)
  mtext(text="Latent rank variables", side=1, line=5.3, outer=TRUE, cex=2.7,
        at=0.5)
  ## top
  mtext(text="Simulated from M2", side=3, line=0, outer=TRUE, cex=3,
        at=0.5, font=2)
  ## left
  mtext(text=rev(c("C-HP  ","C-DCHP","C-MMHP")), side=2, line=0.5, outer=TRUE, 
        at=c(0:2)/3+0.15,
        cex=2, las=2)
}
```

Similarly, we can then repeat this for Fig 4b also for both simulated 
data examples, with slightly more difficulty.

```{r process m1 for fig4b}
plot.s <- 1#7#9
plot.i <- 4
plot.j <- 5

cur_i <- plot.i
cur_j <- plot.j

load(paste0(m1_path,m1_files[plot.s]))

temp.t <- sim_model1_data[[1]]$day_hour[ which(sim_model1_data[[1]]$start == cur_i & 
                  sim_model1_data[[1]]$end == cur_j)]
# temp.t <- test.mmhp$tau
current.n <- length(temp.t)-1
time.segment <- seq(0,tail(temp.t,1),length.out=5000)

### Preprocess the model inference result
## model 1
#########
model1_par_est <- list(lambda0 =
                         mean(sim_model1_stan_sim1_total[[plot.s]]$lambda0[1001:2000]),
                       eta_1=mean(sim_model1_stan_sim1_total[[plot.s]]$eta_1[1001:2000]),
                       eta_2=mean(sim_model1_stan_sim1_total[[plot.s]]$eta_2[1001:2000]),
                       eta_3=mean(sim_model1_stan_sim1_total[[plot.s]]$eta_3[1001:2000]),
                       beta=mean(sim_model1_stan_sim1_total[[plot.s]]$beta[1001:2000]),
                       f=apply(sim_model1_stan_sim1_total[[plot.s]]$f[1001:2000,],2,mean))
lambda.m1<-uniHawkesIntensityNumeric(object=list(lambda0 = 
                                                   model1_par_est$lambda0,
                                    alpha =
                                      model1_fn$alpha.fun(model1_par_est$f[plot.i],
                                    model1_par_est$f[plot.j],
                                    model1_par_est$eta_1,
                                    model1_par_est$eta_2,
                                    model1_par_est$eta_3),
                                    beta=model1_par_est$beta),
                                     events=temp.t,
                                     time.vec=time.segment)


## model2
#############
model2_par_est <- list(gamma=apply(sim_model1_stan_sim2_total[[plot.s]]$gamma[1001:2000,],
                                   2,mean),
                    zeta = 
                      apply(sim_model1_stan_sim2_total[[plot.s]]$zeta[1001:2000,],2,mean),
                       eta_1=mean(sim_model1_stan_sim2_total[[plot.s]]$eta_1[1001:2000]),
                       eta_2=mean(sim_model1_stan_sim2_total[[plot.s]]$eta_2[1001:2000]),
                       eta_3=mean(sim_model1_stan_sim2_total[[plot.s]]$eta_3[1001:2000]),
                       beta=mean(sim_model1_stan_sim2_total[[plot.s]]$beta[1001:2000]),
                       f=apply(sim_model1_stan_sim2_total[[plot.s]]$f[1001:2000,],2,mean))

lambda.m2 <- uniHawkesIntensityNumeric(object=list(
  lambda0=model2_par_est$gamma[plot.i]+
          model2_par_est$zeta[plot.j],                                        
  alpha=model1_fn$alpha.fun(model2_par_est$f[plot.i],
                            model2_par_est$f[plot.j],
                            model2_par_est$eta_1,
                            model2_par_est$eta_2,
                            model2_par_est$eta_3),
                beta=model2_par_est$beta),
                events=temp.t,
                time.vec=time.segment)

## Model3
#############
mmhp_par_est <- list(lambda0=mean(sim_model1_stan_sim3_total[[plot.s]]$lambda0[1001:2000]),
                     lambda1=mean(sim_model1_stan_sim3_total[[plot.s]]$lambda1[1001:2000]),
                     eta_1=mean(sim_model1_stan_sim3_total[[plot.s]]$eta_1[1001:2000]),
                     eta_2=mean(sim_model1_stan_sim3_total[[plot.s]]$eta_2[1001:2000]),
                     eta_3=mean(sim_model1_stan_sim3_total[[plot.s]]$eta_3[1001:2000]),
                     beta=mean(sim_model1_stan_sim3_total[[plot.s]]$beta[1001:2000]),
                     f=apply(sim_model1_stan_sim3_total[[plot.s]]$f[1001:2000,],2,mean))

object_hat <- list(lambda0=mmhp_par_est$lambda0,
                   lambda1=mmhp_par_est$lambda1,
                   alpha=model3_fn$alpha.fun(mmhp_par_est$f[cur_i],
                                             mmhp_par_est$f[cur_j],
                                             mmhp_par_est$eta_1,
                                             mmhp_par_est$eta_2),
                   beta=mmhp_par_est$beta,
                   q1=model3_fn$q1.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3),
                   q2=model3_fn$q0.fun(mmhp_par_est$f[cur_i],
                                       mmhp_par_est$f[cur_j],
                                       mmhp_par_est$eta_3))

### need to load in the interpolated latent state here
#### TO DO ####

state.est.latent.mmhp <- interpolate_state_est_lst[[plot.s]][plot.i,plot.j][[1]]
state.est.latent.mmhp.new <- fixInterpolateState(state.est.latent.mmhp,
                                                 termination=200)

step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,
                        2-state.est.latent.mmhp$z.hat)

lambda.m3 <- mmhpIntensityNumeric(params=object_hat,
                                  t=temp.t[-1],
                                  time.vec=time.segment,
                                  latent.vec=step.fun.est(time.segment))

object_true <- lapply(object_matrix,function(x) x[plot.i,plot.j])
names(object_true) <- c("lambda0","lambda1","alpha","beta","q1","q2")

lambda.true <- mmhpTrueIntensityNumeric(params=object_true,
                                        t=temp.t,
                       latent=list(x=fixStateTransition(test.mmhp)$x,
                              z=fixStateTransition(test.mmhp)$z),
                              time.vec=time.segment)
```


# Figure 5:
```{r data for fig 5,cache=TRUE}
load(paste(sim_data_path,"sim_model3_fit123.RData",sep=''))
load(paste(sim_data_path,"fit123_state_est.RData",sep=''))
## Initialize
N_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1))) 
Lambda_model3_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1))) 
Lambda_model1_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
Lambda_model2_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1))) 
Lambda_true_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1))) 
PR_model1_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
PR_model2_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1))) 
PR_model3_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
PR_true_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1))) 
KS_model1_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_model2_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_model3_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_true_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_p_model1_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_p_model2_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_p_model3_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))
KS_p_true_array <- array(0,dim=c(n_sim,length(object_par$f_vec_1),length(object_par$f_vec_1)))

## Iteration on 50 simulations
for(s in c(1:n_sim)){
  clean_sim_data <- cleanSimulationData(raw_data=sim_model3_data[s][[1]], 
                                        cut_off = cut_off, N = length(object_par$f_vec_1))
  
  N_array[s,,] <- clean_sim_data$N_count
  
  ## model 1
  #########
  model1_par_est <- list(lambda0=mean(sim_model3_stan_sim1[[s]]$lambda0[1001:2000]),
                         eta_1=mean(sim_model3_stan_sim1[[s]]$eta_1[1001:2000]),
                         eta_2=mean(sim_model3_stan_sim1[[s]]$eta_2[1001:2000]),
                         eta_3=mean(sim_model3_stan_sim1[[s]]$eta_3[1001:2000]),
                         beta=mean(sim_model3_stan_sim1[[s]]$beta[1001:2000]),
                         f=apply(sim_model3_stan_sim1[[s]]$f[1001:2000,],2,mean))
  
  for(i in c(1:5)){
    for(j in c(1:5)[-i]){
      current_t <- sim_model3_data[s][[1]]$mmhp_matrix[i,j][[1]]$tau
      m1_object <- list(lambda0=model1_par_est$lambda0,
                        alpha=model1_fn$alpha.fun(model1_par_est$f[i],model1_par_est$f[j],model1_par_est$eta_1,model1_par_est$eta_2,model1_par_est$eta_3),
                        beta=model1_par_est$beta)
      Lambda_model1_array[s,i,j]<-uniHawkesIntegralIntensity(object=m1_object, 
                                                             events=current_t,
                                                             termination = tail(current_t,1))
      Lambda_test <- uniHawkesCompensator(object=m1_object, events=current_t)
      KS_model1_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$statistic
      KS_p_model1_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$p.value
      PR_model1_array[s,i,j] <- uniHawkesPearsonResidual(object=m1_object, 
                                                         events=current_t,
                                                         termination = tail(current_t,1))
    }
  }
  
  ## model2
  #############
  model2_par_est <- list(gamma=apply(sim_model3_stan_sim2[[s]]$gamma[1001:2000,],2,mean),
                         zeta=apply(sim_model3_stan_sim2[[s]]$zeta[1001:2000,],2,mean),
                         eta_1=mean(sim_model3_stan_sim2[[s]]$eta_1[1001:2000]),
                         eta_2=mean(sim_model3_stan_sim2[[s]]$eta_2[1001:2000]),
                         eta_3=mean(sim_model3_stan_sim2[[s]]$eta_3[1001:2000]),
                         beta=mean(sim_model3_stan_sim2[[s]]$beta[1001:2000]),
                         f=apply(sim_model3_stan_sim2[[s]]$f[1001:2000,],2,mean))
  
  for(i in c(1:5)){
    for(j in c(1:5)[-i]){
      current_t <- sim_model3_data[s][[1]]$mmhp_matrix[i,j][[1]]$tau
      m2_object <- list(lambda0=model2_par_est$gamma[i]+model2_par_est$zeta[j],
                        alpha=model1_fn$alpha.fun(model2_par_est$f[i],model2_par_est$f[j],model2_par_est$eta_1,model2_par_est$eta_2,model2_par_est$eta_3),
                        beta=model2_par_est$beta)
      Lambda_model2_array[s,i,j]<-uniHawkesIntegralIntensity(object=m1_object, 
                                                             events=current_t,
                                                             termination = tail(current_t,1))
      Lambda_test <- uniHawkesCompensator(object=m2_object, events=current_t)
      KS_model2_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$statistic
      KS_p_model2_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$p.value
      PR_model2_array[s,i,j] <- uniHawkesPearsonResidual(object=m2_object, 
                                                         events=current_t,
                                                         termination = tail(current_t,1))
    }
  }
  
  ## Model3 & true model
  ######
  mmhp_par_est <- list(lambda0=mean(sim_model3_stan_sim3[[s]]$lambda0[1001:2000]),
                       lambda1=mean(sim_model3_stan_sim3[[s]]$lambda1[1001:2000]),
                       eta_1=mean(sim_model3_stan_sim3[[s]]$eta_1[1001:2000]),
                       eta_2=mean(sim_model3_stan_sim3[[s]]$eta_2[1001:2000]),
                       eta_3=mean(sim_model3_stan_sim3[[s]]$eta_3[1001:2000]),
                       beta=mean(sim_model3_stan_sim3[[s]]$beta[1001:2000]),
                       f=apply(sim_model3_stan_sim3[[s]]$f[1001:2000,],2,mean))
  clean_sim_data <- cleanSimulationData(raw_data=sim_model3_data[s][[1]], 
                                        cut_off = cut_off, N = length(object_par$f_vec_1))
  
  for(i in c(1:5)){
    for(j in c(1:5)[-i]){
      test.mmhp <- sim_model3_data[s][[1]]$mmhp_matrix[i,j][[1]]
      temp.t <- test.mmhp$tau
      current.n <- length(temp.t)-1
      time.segment <- seq(0,tail(temp.t,1),length.out=10000)
      
      object_hat <- list(lambda0=mmhp_par_est$lambda0,
                         lambda1=mmhp_par_est$lambda1,
                         alpha=model3_fn$alpha.fun(mmhp_par_est$f[i],
                                                   mmhp_par_est$f[j],
                                                   mmhp_par_est$eta_1,
                                                   mmhp_par_est$eta_2),
                         beta=mmhp_par_est$beta,
                         q1=model3_fn$q1.fun(mmhp_par_est$f[i],
                                             mmhp_par_est$f[j],
                                             mmhp_par_est$eta_3),
                         q2=model3_fn$q0.fun(mmhp_par_est$f[i],
                                             mmhp_par_est$f[j],
                                             mmhp_par_est$eta_3))
      
      object_true <- lapply(object_matrix,function(x) x[i,j])
      names(object_true) <- c("lambda0","lambda1","alpha","beta","q1","q2")
      
      ## est Lmabda and [R]
      Lambda.test <- mmhpCompensator(params=object_hat, 
                                     t=temp.t,
                                     pzt=2-event_state_est_lst[[s]][i,j][[1]]$zt_v,
                                     if.pzt=FALSE)
      KS_model3_array[s,i,j] <-  ks.test(Lambda.test,"pexp")$statistic
      KS_p_model3_array[s,i,j] <-  ks.test(Lambda_test,"pexp")$p.value
      state.est.latent.mmhp <- interpolate_state_est_lst[[s]][i,j][[1]]
      step.fun.est <- stepfun(state.est.latent.mmhp$x.hat,2-state.est.latent.mmhp$z.hat)
      est.intensity <- mmhpIntensityNumeric(params=object_hat,
                                            t=temp.t[-1],
                                            time.vec=time.segment,
                                            latent.vec=step.fun.est(time.segment))
      est.intensity.events <- mmhpIntensityAtEvents(params=object_hat, t=temp.t,
                                                    latent_z=event_state_est_lst[[s]][i,j][[1]]$zt_v)
      Lambda_model3_array[s,i,j] <- sum(est.intensity)*(time.segment[2]-time.segment[1])
      PR_model3_array[s,i,j] <- sum(1/sqrt(est.intensity.events))-
        sum(sqrt(est.intensity))*(time.segment[2]-time.segment[1])
      
      ## Under the true model
      Lambda.test.true <- mmhpCompensator(params=object_true,
                                          t=temp.t,
                                          pzt=2-test.mmhp$zt[2:length(test.mmhp$zt)],
                                          if.pzt=FALSE)
      KS_true_array[s,i,j] <-  ks.test(Lambda.test.true,"pexp")$statistic
      KS_p_true_array[s,i,j] <-  ks.test(Lambda.test.true,"pexp")$p.value
      true.intensity <- mmhpTrueIntensityNumeric(params=object_true, t=temp.t,
                                                 latent=list(x=fixStateTransition(test.mmhp)$x,
                                                             z=fixStateTransition(test.mmhp)$z),
                                                 time.vec=time.segment)
      true.intensity.events <- mmhpIntensityAtEvents(params=object_true, t=temp.t, 
                                                     latent_z=test.mmhp$zt)
      Lambda_true_array[s,i,j] <- sum(true.intensity$lambda.t)*(time.segment[2]-time.segment[1])
      PR_true_array[s,i,j] <- sum(1/sqrt(true.intensity.events))-
        sum(sqrt(true.intensity$lambda.t))*(time.segment[2]-time.segment[1])
    }
  }
}

```


```{r fig5-residual-ks, fig.height=7}
cols_plot <- viridis::viridis(4)
#load("../output/sim_model3_fit123_residuals.RData")
par(mfrow=c(5,5),mar=rep(0.2,4),oma=c(2.4,2.4,0.5,0.5))
for(i in c(5:1)){
  for(j in c(5:1)){
    if(i==j){
      plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),
           bty="n", xlab="",ylab="",xaxt="n",yaxt="n",axes=FALSE)
      if(i==5){
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04,col=cols_plot[1],border=NA)
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04-0.22,col=cols_plot[2],border=NA)
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04-0.44,col=cols_plot[3],border=NA)
        polygon(c(0,0,0.15,0.15),c(0.72,0.8,0.8,0.72)+0.04-0.66,col=cols_plot[4],border=NA)
        text(c(0.43,0.58,0.61,0.4),seq(0.8,0.14,-0.22),
             c("C-HP", "C-DCHP", "C-MMHP", "True"),
             cex=1.7)
      }
    }else{
      # PR <- c((N_array-Lambda_model1_array)[,i,j],(N_array-Lambda_model2_array)[,i,j],
      #         (N_array-Lambda_model3_array)[,i,j],(N_array-Lambda_true_array)[,i,j])
      PR <- c(KS_model1_array[,i,j],KS_model2_array[,i,j],
              KS_model3_array[,i,j],KS_true_array[,i,j])
      Type <- c(rep(1,n_sim),rep(2,n_sim),rep(3,n_sim),rep(4,n_sim))
      boxplot(PR ~ Type,  
              col = cols_plot,
              #col = c("steelblue", "goldenrod2", "firebrick2", "chartreuse3"),   
              xlab="",ylab="",xaxt="n",yaxt="n")#names = c("C-HP", "C-HP-DC", "C-MMHP", "True")
    }
  }
}
mtext(text=c(1:5), side=2, line=0.5, outer=TRUE, cex=2, las=2,
      at=c(0:4)/5+0.1)
mtext(text=c(5:1), side=1, line=1, outer=TRUE, cex=2,
      at=c(0:4)/5+0.1)

```


# Figure 6: Latent Rank Cohort comparison


## Figure 6a: Rank vs I&SI


```{r fig-6a-rank-vs-isi}
### Rank Comparison for Single Cohort ####
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/agg_rank_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_mmhp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))

no_method <- 4
plot_latent_df <- data.frame(Methods=rep(1:no_method,each=1000*mice_number),
                             Mice=rep(rep(1:mice_number,each=1000),no_method),
                             force=rep(0,1000*mice_number*no_method))
## agg
plot_latent_df$force[(1:(1000*mice_number))] <- as.vector(sim_agg_rank$x[1001:2000,])

## M1
plot_latent_df$force[(1:(1000*mice_number))+1000*mice_number] <- as.vector(sim_cohort_hp$f)

## M2
plot_latent_df$force[(1:(1000*mice_number))+2000*mice_number] <- as.vector(sim_cohort_dchp$f)

## M3
plot_latent_df$force[(1:(1000*mice_number))+3000*mice_number] <- as.vector(sim_cohort_mmhp$f)

plot_latent_df$Mice <- factor(plot_latent_df$Mice,
                              levels = expert_rank_10[[current_cohort]])
plot_latent_df$Method <- factor(plot_latent_df$Method,
                                labels = c("AggRanking","C-HP","C-DCHP","C-MMHP"))

# png(paste(plot_path,"real_rank_one_cohort.png",sep=""),width=600,height=300)

p1 <- ggplot(plot_latent_df, 
             aes(x = Mice, y = force, fill = Method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = viridis::viridis(4))+
  #scale_fill_manual(values = c("gray", "steelblue", "goldenrod2" , "firebrick2")) +
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 10),
        legend.position="none") +
  facet_grid(cols=vars(Method)) +
  xlab("Mice (ranked by I&SI method)") +
  ylab("Latent rank")
p1
#dev.off()

```
## Figure 6b: Spearman rank correlation



```{r fig-6b-overall-rank-correlation}
load("../output/weighted_rank_data.RData")
#png(paste(plot_path,"real_rank_all_cohort.png",sep=""),width=600,height=300)
no_method <- 4
plot_cor_df <- data.frame(Method=rep(c(1:no_method),each=10),
                          cor=as.vector(spearman_df))
plot_cor_df$Method <- factor(plot_cor_df$Method,
                             labels = c("Agg-rank","C-HP","C-DCHP","C-MMHP"))
p2 <- ggplot(plot_cor_df, aes(x="", y = cor, fill = Method)) +
        geom_boxplot(alpha=0.7, width=0.5) +
        scale_fill_manual(values = viridis::viridis(4)) + 
        ggtitle("(b)") +
        ylim(0,1) +
        theme_bw() +
        theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
              text = element_text(size = 20),
              axis.text.y =element_text(size = 11),
              legend.position="none",
              axis.title.x=element_blank()) +
        facet_grid(cols=vars(Method)) +
        ylab("Spearman rank correlation")
p2


```

```{r fig-rank-slides, fig.height=3,include=slides_plots,eval=slides_plots}

p2_slides <- plot_cor_df %>%
  filter(Method != "Agg-rank") %>%      
  ggplot(aes(x="", y = cor, fill = Method)) +
        geom_boxplot(alpha=0.7, width=0.5) +
        scale_fill_manual(values = viridis::viridis(3)) + 
        #ggtitle("(b)") +
        ylim(0,1) +
        theme_bw() +
        theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
              text = element_text(size = 20),
              axis.text.y =element_text(size = 11),
              legend.position="none",
              axis.title.x=element_blank()) +
        facet_grid(cols=vars(Method)) +
        ylab("Rank correlation")
p2_slides

```


# Figure 7: Pearson residual matrices



```{r fig-7-prMatrix-Cohort5, fig.height=7}
# current_cohort <- 5

m1_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                   "/chp_pr_matrix_",cohort_names[current_cohort],
                   ".RDS",sep=''))

m2_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/dchp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

m3_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/cmmhp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

indep_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/immhp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

matrix_lst_plot <- list(
                        indep_pr[rev(expert_rank_10[[current_cohort]]),
                                                                   expert_rank_10[[current_cohort]]],
                        m1_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]],
                        m2_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]],
                        m3_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]]) 
#cat("Cohort ",current_cohort,"\n",sep="")
myMultiMatrixPlot(X=matrix_lst_plot,no_matrix=4,n_row=2,
                  xLabels=expert_rank_10[[current_cohort]],
                  yLabels=rev(expert_rank_10[[current_cohort]]),
                  min=-80,max=80,axis_cex=2,title_cex = 1.8,
                  colorPalette="RdBu",if.emp=FALSE,
                  #legend.mar=c(0.5,.5,0.5,0.5),
                  title_lst=list("I-MMHP","C-HP","C-DCHP","C-MMHP"), 
                  #title_lst = list("I-MMHP"),
                  col_axis=c(-80,-40,0,40,80), fake_matrix=FALSE,
                  matrix.mar=c(2.5,2.5,2.5,1)
                  )


```

```{r fig_pr_slides, fig.height=3, fig.width=7, include=slides_plots,eval=slides_plots}
# current_cohort <- 5

m1_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                   "/chp_pr_matrix_",cohort_names[current_cohort],
                   ".RDS",sep=''))

m2_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/dchp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

m3_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/cmmhp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

indep_pr <- readRDS(paste(data_path,cohort_names[current_cohort],
                     "/immhp_pr_matrix_",cohort_names[current_cohort],
                     ".RDS",sep=''))

matrix_lst_plot <- list(
                        #indep_pr[rev(expert_rank_10[[current_cohort]]),
#                                                                   #expert_rank_10[[current_cohort]]],
                        m1_pr[rev(expert_rank_10[[current_cohort]]),
                                                                  expert_rank_10[[current_cohort]]],
                        m2_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]],
                        m3_pr[rev(expert_rank_10[[current_cohort]]),
                                                                 expert_rank_10[[current_cohort]]]) 
#cat("Cohort ",current_cohort,"\n",sep="")
myMultiMatrixPlot(X=matrix_lst_plot,no_matrix=3,n_row=1,
                  xLabels=expert_rank_10[[current_cohort]],
                  yLabels=rev(expert_rank_10[[current_cohort]]),
                  min=-80,max=80,axis_cex=1,title_cex = 1.8,
                  colorPalette="RdBu",if.emp=FALSE,
                  #legend.mar=c(0.5,.5,0.5,0.5),
                  title_lst=list("C-HP","C-DCHP","C-MMHP"), 
                  #title_lst = list("I-MMHP"),
                  col_axis=c(-80,-40,0,40,80), fake_matrix=FALSE,
                  matrix.mar=c(2.5,2.5,2.5,0.5)
                  )



```



<!-- The remaining plot code seems to mostly be in `PaperPlots.R`. -->

# Figure 8

## Figure 8a: Frobenius norm of interaction predictions, single cohort

```{r fig-8a-frob-norm-cohort5}
load("../output/plot_N_predict.RData")
# current_cohort <- 5# cohort 1 looks worse than rest

temp_plot_df <- predict_day_norm_df_lst[[current_cohort]]
temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
#png(paste(plot_path,"real_predict_N_one_cohort.png",sep=""),width=600,height=300)
p3 <- temp_plot_df %>%
  rowwise() %>%
  #mutate(norm = min(norm,60)) %>%
  ggplot( aes(x = method, y = norm, fill = method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = viridis::viridis(5)) +
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("Frobenius norm of error") +
  ylim(0, 150) + # aren't infinite but >150 and <200
  NULL
p3
```


```{r fig-pred-cohort-slides, include=slides_plots,eval=slides_plots, fig.height=3}
load("../output/plot_N_predict.RData")
# current_cohort <- 5# cohort 1 looks worse than rest
# 3 looks nice

temp_plot_df <- predict_day_norm_df_lst[[current_cohort]]
temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
#png(paste(plot_path,"real_predict_N_one_cohort.png",sep=""),width=600,height=300)
p3_slides <- temp_plot_df %>%
  filter(method != "I-MMHP") %>%
  rowwise() %>%
  #mutate(norm = min(norm,100)) %>%
  ggplot( aes(x = method, y = norm, fill = method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = viridis::viridis(5)) +
  #ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(),
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("Frobenius norm of error") +
  ylim(0, 80) +
  NULL
p3_slides
```


## Figure 8b: Same plot aggregated for all cohorts

```{r fig-8b-frob-norm-all-cohorts}
load("../output/plot_N_predict.RData")
temp_plot_df <- all_cohort_norm_df %>% 
  group_by(day, method) %>% 
  summarise(avg=mean(norm), n= n(), sd=sd(norm))

temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)

#png(paste(plot_path,"real_predict_N_all_cohort.png",sep=""),width=600,height=300)
p4 <- ggplot(temp_plot_df, aes(x=day, y=avg, group=method, color=method)) + 
  geom_line(size=1.2, alpha=0.8, position=position_dodge(0.2)) +
  geom_errorbar(aes(ymin=avg-sd, ymax=avg+sd), width=0.8, size=0.8, alpha=0.8,
                 position=position_dodge(0.2)) +
  scale_color_manual(values = viridis::viridis(5)) + 
  ggtitle("(b)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 18)) +
  xlab("Prediction horizon (day)") + 
  ylab("Frobenius norm of error") + 
  coord_cartesian(ylim=c(2.5,57.5)) + 
  guides(color=guide_legend(title="Model")) 
p4
```


```{r fig-slides-predict,include=slides_plots,eval=slides_plots,fig.height=3}
load("../output/plot_N_predict.RData")
temp_plot_df <- all_cohort_norm_df %>% 
  group_by(day, method) %>% 
  summarise(avg=mean(norm), n= n(), sd=sd(norm),
            se = sd/sqrt(n))

temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)

#png(paste(plot_path,"real_predict_N_all_cohort.png",sep=""),width=600,height=300)
p4_slides <- ggplot(temp_plot_df, 
                    aes(x=day, y=avg, group=method, color=method)) + 
  geom_line(size=1.2, alpha=0.8, position=position_dodge(0.2)) +
  geom_errorbar(aes(ymin=avg-sd, ymax=avg+sd), width=0.8, size=0.8, alpha=0.8,
                 position=position_dodge(0.2)) +
  scale_color_manual(values = viridis::viridis(5)) + 
  #ggtitle("(b)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 18)) +
  xlab("Prediction horizon (day)") + 
  ylab("Frobenius norm of error") + 
  coord_cartesian(ylim=c(2.5,57.5)) + 
  guides(color=guide_legend(title="Model")) 
p4_slides

```



```{r, include=FALSE,eval=FALSE}

all_sims <- do.call(rbind,predict_day_norm_df_lst)

temp_plot_df <- all_sims %>% 
  group_by(day, method) %>% 
  summarise(avg=mean(norm), n= n(), sd=sd(norm),
            se = sd/n)

temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
p4_slides <- temp_plot_df %>% #filter(method != "C-HP") %>% 
  filter(method != "I-MMHP") %>%
  ggplot(aes(x=day, y=avg, group=method, color=method)) + 
  geom_line(size=1.2, alpha=0.8, position=position_dodge(0.2)) +
  geom_errorbar(aes(ymin=avg-sd, ymax=avg+sd), width=0.8, size=0.8, alpha=0.8,
                 position=position_dodge(0.2)) +
  scale_color_manual(values = viridis::viridis(5)) + 
  #ggtitle("(b)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 18)) +
  xlab("Prediction horizon (day)") + 
  ylab("Frobenius norm of error") + 
  coord_cartesian(ylim=c(2.5,57.5)) + 
  guides(color=guide_legend(title="Model")) #+ ylim(c(0,1000))
p4_slides


```



# Figure 9

## Figure 9a: Predicted Spearman rank for single cohort

```{r fig-9a-spearman-rank-cohort1}
load("../output/plot_rank_predict.RData")
# current_cohort <- 5
temp_plot_df <- predict_day_rank_df_lst[[current_cohort]]
temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
# png(paste(plot_path,"real_predict_rank_one_cohort.png",sep=""),width=600,height=300)
p5 <- ggplot(temp_plot_df, aes(x = method, y = spearman, fill = method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = viridis::viridis(5)) +
  #scale_fill_manual(values = c("gray","yellowgreen","steelblue","goldenrod2","firebrick2")) + 
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("Spearman rank correlation") +
  ylim(0, 1)
p5
```


```{r fig-pred-cor, eval=slides_plots,include=slides_plots,fig.height=3}
load("../output/plot_rank_predict.RData")
# current_cohort <- 5
temp_plot_df <- predict_day_rank_df_lst[[current_cohort]]
temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)
# png(paste(plot_path,"real_predict_rank_one_cohort.png",sep=""),width=600,height=300)
temp_plot_df <- temp_plot_df %>%
  filter(method != "I-MMHP") 
p5 <- ggplot(temp_plot_df, aes(x = method, y = spearman, fill = method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = viridis::viridis(5)) +
  #scale_fill_manual(values = c("gray","yellowgreen","steelblue","goldenrod2","firebrick2")) + 
  #ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_blank(),
        axis.ticks.x = element_blank(), 
        legend.position="right") +
  facet_grid(cols=vars(day)) +
  xlab("Prediction horizon (day)") + 
  ylab("Rank correlation") +
  ylim(0, 1)
p5
```



## Figure 9b: Predicted Spearman rank for all cohorts

```{r fig-9b-spearman-rank-all-cohorts}
load("../output/plot_rank_predict.RData")
temp_plot_df <- all_cohort_rank_df %>% 
  group_by(day, method) %>% 
  summarize(avg=mean(spearman), n= n(), sd=sd(spearman))

temp_plot_df$method <- factor(temp_plot_df$method,
                              levels = c("mmhp","dsnl","m1","m2","m3"),
                              labels = c("I-MMHP","DSNL","C-HP","C-DCHP","C-MMHP"))
temp_plot_df$day <- factor(temp_plot_df$day)

# png(paste(plot_path,"real_predict_rank_all_cohort.png",sep=""),width=600,height=300)
p6 <- ggplot(temp_plot_df, aes(x=day, y=avg, group=method, color=method)) + 
  geom_line(size=1.2, alpha=0.8, position=position_dodge(0.2)) +
  geom_errorbar(aes(ymin=avg-sd, ymax=avg+sd), width=0.8, size=0.8, alpha=0.8,
                position=position_dodge(0.2)) +
  scale_color_manual(values = viridis::viridis(5)) +
  #scale_color_manual(values = c("gray","yellowgreen","steelblue","goldenrod2","firebrick2")) +
  ggtitle("(b)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 18)) +
  xlab("Prediction horizon (day)") + 
  ylab("Spearman rank correlation") + 
  coord_cartesian(ylim=c(0,1)) + 
  guides(color=guide_legend(title="Model")) 
p6
```


# Figure 10

## Figure 10a


```{r construct data for plot, results='hide',message=FALSE,cache=TRUE}
library(PlayerRatings)

# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
           "/predict_simulation_",cohort_names[current_cohort],
           ".RData",sep=''))
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]],
                        cut_off = 1)

df <- full_data[[cohort_names[current_cohort]]]
df <- df[df$Actor!="Start"&df$Actor!="End",]
df1 <- expandrows(df)
df1 <- df1[order(df1$Timestamp),] #ensure in date order
df1$event <- 1:nrow(df1)
glick.df <- df1[, c("event","Actor","Recipient","score"), with = FALSE] #need event, actor, recipient, score
gl <- my_glicko(glick.df, history=TRUE, cval=2)

# ------------------- period
training_end <- nrow(df[df$day<=18,])
testing_end <- nrow(df)-1#1077 #929 for cohort 5
newx <- c(training_end:testing_end)

# ----------------- set pars for plot
my_col <- c("black", "grey", "orange", "red")
col_vec <- colorRampPalette(my_col)(mice_number)
ltypes_vec <- rep(1,mice_number) #c(1,2,3,1,2,3,1,2,3,1,2,3)
history_width <- 3
sim_width <- 0.3
shade_vec <- makeTransparent(col_vec,0.2)
less_shade_vec <- makeTransparent(col_vec,0.7)

# ---------------- simulation mean and sd
sim_gl_array <- array(NA, dim=c(12,testing_end-training_end+1,1000))
for(s in 1:1000){
  print(s)
  temp_gl <- glickoScoreSimulationWithWindowsReturnAll(
    predict.sim = m3_predict_sim[5:8,s], #7 for c 2 and 10
    history.df = glick.df[1:training_end,])
  history_matrix <- temp_gl$history[,,1]
  
  if(testing_end>ncol(temp_gl$history[,,1])){
    history_matrix <- cbind(history_matrix,
                            t(matrix(rep(history_matrix[,ncol(history_matrix)],
                                         testing_end-ncol(temp_gl$history[,,1])),
                                     nrow=testing_end-ncol(temp_gl$history[,,1]),
                                     byrow=TRUE)))
  }else{
    # this line makes no sense, and should likely never happen
    # try(
    history_matrix <- history_matrix[,1:testing_end]#temp_gl$history[,1:testing_end]
    # )
  }
  sim_gl_array[,,s] <- history_matrix[,training_end:testing_end]
}
```



```{r fig-10a-glicko-rating}
par(mar=c(3,5,3,1))
plot(1, type="n", xlab="", ylab="Glicko ranking", xlim=c(0,dim(gl$history)[2]),
     ylim=c(min(gl$history[,,1]),max(gl$history[,,1])),
     cex.axis=2, cex.lab=2)
for(m in c(1:mice_number)){
  #history
  lines(gl$history[m,1:training_end,1],
        cex=0.6, col=col_vec[m],lwd=history_width,lty=ltypes_vec[m])
  lines(c(rep(NA,training_end), gl$history[m,(training_end+1):testing_end,1]),
        cex=0.6, col=shade_vec[m],lwd=history_width,lty=ltypes_vec[m])
  
  #simulation
  cur_end <- testing_end
  mean_vec <- apply(sim_gl_array[m,,],1,function(x) mean(na.omit(x)))
  sd_vec <- apply(sim_gl_array[m,,],1,function(x) sd(na.omit(x)))
  polygon(c(newx, rev(newx)), c(mean_vec-sd_vec,rev(mean_vec+sd_vec)),col = shade_vec[m], border = NA)
  #polygon(c(newx), c(mean_vec-sd_vec),col = shade_vec[m], border = NA)
  lines(c(rep(NA,training_end),mean_vec),
        cex=0.6, col=col_vec[m],lwd=1,lty=2)
}

# annotate the days
for(d in c(19:21)){
  abline(v = nrow(df[df$day<=(d-1),]),lty=2,lwd=0.4)
  text(x=nrow(df[df$day<=(d-1),]),y=2600,d)
}
mtext(text="(a)", side=3, line=-2.3, outer=TRUE, cex=2.8, at=0.5, font=2)
```

```{r fig-glicko-pred-slides,eval=slides_plots,include=slides_plots}
par(mar=c(3,5,3,1))
plot(1, type="n", xlab="", ylab="Glicko ranking", xlim=c(0,dim(gl$history)[2]),
     ylim=c(min(gl$history[,,1]),max(gl$history[,,1])),
     cex.axis=2, cex.lab=2)
for(m in c(1:mice_number)){
  #history
  lines(gl$history[m,1:training_end,1],
        cex=0.6, col=col_vec[m],lwd=history_width,lty=ltypes_vec[m])
  lines(c(rep(NA,training_end), gl$history[m,(training_end+1):testing_end,1]),
        cex=0.6, col=shade_vec[m],lwd=history_width,lty=ltypes_vec[m])
  
  #simulation
  cur_end <- testing_end
  mean_vec <- apply(sim_gl_array[m,,],1,function(x) mean(na.omit(x)))
  sd_vec <- apply(sim_gl_array[m,,],1,function(x) sd(na.omit(x)))
  polygon(c(newx, rev(newx)), c(mean_vec-sd_vec,rev(mean_vec+sd_vec)),col = shade_vec[m], border = NA)
  #polygon(c(newx), c(mean_vec-sd_vec),col = shade_vec[m], border = NA)
  lines(c(rep(NA,training_end),mean_vec),
        cex=0.6, col=col_vec[m],lwd=1,lty=2)
}

# annotate the days
for(d in c(19:21)){
  abline(v = nrow(df[df$day<=(d-1),]),lty=2,lwd=0.4)
  text(x=nrow(df[df$day<=(d-1),]),y=2600,d)
}
#mtext(text="(a)", side=3, line=-2.3, outer=TRUE, cex=2.8, at=0.5, font=2)
```




```{r remove some objects, include=FALSE}
rm(m3_predict_sim)
rm(m2_predict_sim)
rm(m1_predict_sim)
rm(mmhp_predict_sim)
rm(fit_agg_rank)
rm(fit_cohort_hp)
rm(fit_cohort_dchp)
rm(fit_cohort_mmhp)

# also removing stan fits as they can cause issues in the next chunk

```


## Fig 10b

```{r process for state separation cohort5,eval=FALSE}
# only run this once and save the results
# this doesn't need to be rerun ever, even if the stan fits change
# current_cohort <- 5

load(paste(data_path,cohort_names[current_cohort],
             "/cmmhp_est_zt_",cohort_names[current_cohort],
             ".RData",sep=''))
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("day","observe.id","observe.time")])

## 5.  find how many 1s for each pair
print(".......state separation plot........")
total_event_array <- array(0,dim=c(mice_number,mice_number,max(return_df$observe.id)))
active_event_array <- array(0,dim=c(mice_number,mice_number,max(return_df$observe.id)))

for(i in 1:mice_number){
  for(j in c(1:mice_number)[-i]){
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0){
      current_window_vec <- unique_pairs_df$observe[[pair]]
      for(cur_win in current_window_vec){
        row_indicator <- return_df$initiator==i&return_df$recipient==j&return_df$observe.id==cur_win
        total_event_array[i,j,cur_win] <- length(return_df[row_indicator,"event.times"][[1]])
        active_event_array[i,j,cur_win] <- sum(apply(2-state_array_list[[pair]][[cur_win]],1,mean) > 0.5)
      }
    }
  }
}

utility_state_day <- array(0,dim=c(21,mice_number,mice_number))
social_state_day <- array(0,dim=c(21,mice_number,mice_number))
for(cur_day in c(1:21)){
  cur_wins <- which(unique_observe_win$day==cur_day)
  utility_state_day[cur_day,,] <- apply(active_event_array[,,cur_wins],c(1,2),sum)
  social_state_day[cur_day,,] <- apply(total_event_array[,,cur_wins],c(1,2),sum)-utility_state_day[cur_day,,]
}


## utility dsnl
fit_dsnl_active <- stan("../lib/dsnl_poisson.stan",
                         data=list(day=21,
                                   Gt=utility_state_day,
                                   c=1,
                                   sigma=0.5),
                         iter=1000, chains=4, control=list(adapt_delta=0.99))
print(fit_dsnl_active,pars=c("x"))
sim_dsnl_active <- rstan::extract(fit_dsnl_active)

## social dsnl
fit_dsnl_inactive <- stan("../lib/dsnl_poisson.stan",
                           data=list(day=21,
                                     Gt=social_state_day,
                                     c=1,
                                     sigma=1),
                           iter=1000, chains=4, control=list(adapt_delta=0.99))
print(fit_dsnl_inactive,pars=c("x"))
sim_dsnl_inactive <- rstan::extract(fit_dsnl_inactive)

save(sim_dsnl_active, fit_dsnl_active, utility_state_day,
     sim_dsnl_inactive, fit_dsnl_inactive, social_state_day,
     file = paste(data_path,cohort_names[current_cohort],
                  "/dsnl_state_separation_stan_result_",cohort_names[current_cohort],
                  ".RData",sep=''))
rm(interpolation_array_list)
rm(state_array_list)
rm(termination_state_list)
rm(initial_state_list)
```


```{r process data for plot 10b}
library(PlayerRatings)
# current_cohort <- 5
load(paste(data_path,cohort_names[current_cohort],
           "/dsnl_poisson_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/dsnl_state_separation_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
sub.types <- c("All", "Active", "Inactive"); # three methods
task.types <- paste0("day", 1:21);  

data.tbl <- data.frame(array(NA, c(2000*3*21, 3)))
colnames(data.tbl) <- c("sub.type", "task.type", "data.value")  
source('../lib/myGlicko.R')
#------------ gl score
df <- full_data[[cohort_names[current_cohort]]]
df <- df[df$Actor!="Start"&df$Actor!="End",]
df1 <- expandrows(df)
df1 <- df1[order(df1$Timestamp),] #ensure in date order
df1$event <- 1:nrow(df1)
glick.df <- df1[, c("event","Actor","Recipient","score"), with = FALSE] #need event, actor, recipient, score
real.gl <- my_glicko(glick.df, history=TRUE, cval=2)
clean_data_all <- cleanData(full_data[[cohort_names[current_cohort]]],
                              cut_off = 1)
day_end_idx <- unlist(lapply(c(1:21),function(x) max(which(clean_data_all$day==x))))

## All aggregate
for (t in 1:length(task.types)){
  temp_vec <- rep(NA,2000)
  cur_real_rank <- real.gl$history[,day_end_idx[t],1]
  for(s in c(1:2000)){
    temp_result <- cor.test(sim_dsnl$x[s,t,], cur_real_rank,
                            method = "spearman")
    temp_vec[s] <- temp_result$estimate
  }
  data.tbl$sub.type[(1:2000)+(t-1)*2000] <- sub.types[1]  
  data.tbl$task.type[(1:2000)+(t-1)*2000] <- task.types[t];  
  data.tbl$data.value[(1:2000)+(t-1)*2000] <- temp_vec
}  

## Utility aggregate
for (t in 1:length(task.types)){
  temp_vec <- rep(NA,2000)
  cur_real_rank <- real.gl$history[,day_end_idx[t],1]
  for(s in c(1:2000)){
    temp_result <- cor.test(-sim_dsnl_active$x[s,t,], cur_real_rank, method = "spearman")
    temp_vec[s] <- temp_result$estimate
  }
  data.tbl$sub.type[(1:2000)+(t-1)*2000+42000] <- sub.types[2]  
  data.tbl$task.type[(1:2000)+(t-1)*2000+42000] <- task.types[t];  
  data.tbl$data.value[(1:2000)+(t-1)*2000+42000] <- temp_vec
}  

## Social aggregate
for (t in 1:length(task.types)){
  temp_vec <- rep(NA,2000)
  cur_real_rank <- real.gl$history[,day_end_idx[t],1]
  for(s in c(1:2000)){
    temp_result <- cor.test(sim_dsnl_inactive$x[s,t,], 
                            cur_real_rank, method = "spearman")
    temp_vec[s] <- temp_result$estimate
  }
  data.tbl$sub.type[(1:2000)+(t-1)*2000+42000*2] <- sub.types[3]  
  data.tbl$task.type[(1:2000)+(t-1)*2000+42000*2] <- task.types[t];  
  data.tbl$data.value[(1:2000)+(t-1)*2000+42000*2] <- temp_vec
}  

data.tbl$sub.type <- factor(data.tbl$sub.type);  
data.tbl$task.type <- factor(data.tbl$task.type);
```




```{r fig-10b-rank-correlation}
par(mar=c(3,5,3,1))
cx <- 1.75  # cex for axis label text; 
# default is 1. bigger numbers make the text bigger, smaller, smaller.  
x.ttl <- ""; # blank x-axis label  
y.ttl <- "rank corr. (expert rank)";  
ttl <- "(b)";  
#y.lim <- c(min(data.tbl$data.value), max(data.tbl$data.value)+.5);
# y-axis limits. +2 at top to give room for legend  
y.lim <- c(-1,1.2)    
x.lim <- c(0.5, (length(task.types))) 
cols <- c('paleturquoise4', 'lightgreen', 'cornsilk')
shifts <- c(-0.25, 0, 0.25)
 
plot(x = 0, y = 0, xlim = x.lim, ylim = y.lim, xaxt='n',
     col = 'white', xlab = x.ttl,
     ylab = y.ttl, main = ttl,
     cex.main = cx*1.3, cex.axis = cx, cex.lab = cx); 
axis(side = 1, at = 1:length(task.types), labels = task.types,
     cex.axis=cx, cex.lab=cx)  # put on the x-axis labels  
grid(nx=NA, ny=NULL, col='darkgrey');  
lines(x=c(-1,100), y=c(0,0), col='darkgrey');  
for (t.id in 1:length(task.types)) {  
  for (i in 1:length(sub.types)) {  # t.id <- 1; i <- 1;   
   inds <- which(data.tbl$sub.type == sub.types[i] & 
                   data.tbl$task.type == task.types[t.id])
   boxplot(data.tbl$data.value[inds], at=t.id+shifts[i],
           col=cols[i], add=TRUE, 
           xaxt='n', yaxt='n', bty='n', boxwex=0.35,
           outpch = 20, outcex = 0.5) 
  }  
}  
legend(x='top', legend = sub.types, fill=cols,
       horiz = TRUE, cex = cx, bg = 'white', bty = 'n')  
box()
```

