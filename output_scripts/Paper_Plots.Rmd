---
title: "Plots for Latent Hawkes Paper"
author: "Owen G. Ward"
date: '`r Sys.Date()`'
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: FALSE
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.path = "paper_figure/",
                      dev = 'png', fig.height = 4.5, fig.width = 7,
                      warning = FALSE)
```

```{r load_packages, include=FALSE}

# don't write to this path
data_path <- "../output/"

func_dir <- "../lib/"


library(rstan)
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
options(mc.cores = parallel::detectCores())
library(tidyverse)
library(R.utils)
library(RColorBrewer)
library(fields)
library(bayesplot)
library(viridis)
library(compete)
library(colorspace)
source(paste(func_dir,'naiveRankHierarchy.R',sep = ""))
source(paste(func_dir,'expertRankHierarchy.R',sep = ""))
source(paste(func_dir,'cleanData.R',sep = "")) 
source(paste(func_dir,'prepareDataStan.R',sep = "")) 
source(paste(func_dir,'inferLatentMmhp.R',sep = ""))
source(paste(func_dir,'plotUtil.R',sep = "")) 
source(paste(func_dir,'mmhp.R',sep = ""))
source(paste(func_dir,'uniHawkes.R',sep = ""))
source(paste(func_dir,'simulatePrediction.R',sep = ""))
source(paste(func_dir,'myGlicko.R',sep = ""))
source(paste(func_dir,'matrixPlotParameter.R',sep = ""))
source(paste(func_dir,'residualStructureScore.R',sep = ""))
source("https://gist.githubusercontent.com/jalapic/6ca3ece44bdcdc522bb735f183aa0ca0/raw/1a07f469eff08117121b6cbebcd22fb7569e3ee8/compete_extra.R")


```



```{r load rankings,echo=FALSE,include=FALSE,results='hide',cache=TRUE}
full_data <- readRDS("../data/mice.RData")
# A=c9, B=c10, C=c12, D=c15, E=c16, F=c17, G=c18, H=c37, I=c38. J=c45
cohort_names <- paste("cohort",c(9,10,12,15,16,17,18,37,38,45),sep='')
cohort_short_names <- paste("C",c(9,10,12,15,16,17,18,37,38,45),sep='')
cut_off <- 3
mice_number <- 12

# Define the cohorts will be fitted
fit_cohorts <- c(1:10)
naive_rank_10 <- list()
expert_rank_10 <- list()
out <- captureOutput(for(current_cohort in fit_cohorts){
  naive_rank_10[[current_cohort]] <- naiveRankHierarchy(full_data[[cohort_names[current_cohort]]])
  expert_rank_10[[current_cohort]] <- expertRankHierarchy(full_data[[cohort_names[current_cohort]]])
})


```

```{r define_functions}
model1_fn <- list(alpha.fun = function(x,y,eta1,eta2,eta3){return(eta1*x*y*exp(-eta2*abs(x-y))/(1+exp(-eta3*(x-y))))})

model3_fn <- list(alpha.fun = function(x,y,eta1,eta2){return(eta1*x*y*exp(-eta2*abs(x-y)))},
                  q1.fun = function(x,y,eta3){return(exp(-eta3*x))},
                  q0.fun = function(x,y,eta3){return(exp(-eta3*y))})


```



The aim of this notebook is a way to quickly and efficiently create all the plots
required for this paper. They will be built with the current fits and models.



# Figure 2: Contour Plot and C-HP Diagnostics

This is not effected by the final model.

## Figure 2a: Contour Plot

```{r fig-2a-contour-plot}
current_cohort <- 1
#png(paste(plot_path,"contour.png",sep=""),width=480,height=480)
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_hp$eta_1)
eta2_mean <- mean(sim_cohort_hp$eta_2)
eta3_mean <- mean(sim_cohort_hp$eta_3)
z.func <- function(x,y){
  return(x*y*eta1_mean*exp(-eta2_mean*abs(x-y))/(1+exp(-eta3_mean*(y-x))))
  # this is because axes are flipped that we have y-x in last term
  #return(x*y*eta1_mean/(1+exp(eta2_mean*abs(x-y)-eta3_mean*(y-x))))
}
z_plot <- outer(seq(1,0,-0.01),  
                seq(0,1,0.01), 
                z.func)
my.image.plot(seq(0,1,0.01), seq(0,1,0.01), z_plot,
              xlab=expression(f[j]),ylab=expression(f[i]),
              my.main="(a)", cex.main=2.3, 
              cex.lab=2.5, xLabels=c(1,0), yLabels=c(0,1))

```


## Fig 2b: C-HP Diagnostics

This is using the correct form of the compensator for a Hawkes process.


```{r fig-2b-diag-plot,echo=FALSE,warning=FALSE}
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
eta1_mean <- mean(sim_cohort_hp$eta_1)
eta2_mean <- mean(sim_cohort_hp$eta_2)
eta3_mean <- mean(sim_cohort_hp$eta_3)
f_est <- apply(sim_cohort_hp$f,2,mean)
clean_data <- cleanData(full_data[[cohort_names[current_cohort]]])
return_df <- cleanObservationPeriod(current_cohort, clean_data)
unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>%
  dplyr::summarize(count=n(),
                   observe=list(observe.id),
                   observe.length=list(observe.time),
                   no.events=list(no.events))
unique_observe_win <- unique(return_df[,c("observe.id","observe.time")])

ks.stat.matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
n_matrix <- matrix(0,ncol=mice_number,nrow=mice_number)
Lambda_matrix <- matrix(list(),nrow=mice_number,ncol=mice_number)
for(k in 1:mice_number){
  for(l in c(1:mice_number)[-k]){
    i<-expert_rank_10[[current_cohort]][k]
    j<-expert_rank_10[[current_cohort]][l]
    pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j)
    if(length(pair)>0){
      param_mean <- list(lambda0=mean(sim_cohort_hp$lambda0),
                         alpha=model1_fn$alpha.fun(f_est[i],f_est[j],
                                                   eta1_mean,eta2_mean,eta3_mean),
                         beta=mean(sim_cohort_hp$beta))
      current_window_vec <- unique_pairs_df$observe[[pair]]
      all_Lambda <- numeric(0)
      for(cur in c(1:length(current_window_vec))){ ## check length > 2
        cur_win <- current_window_vec[cur]
        current_event_time <- return_df[return_df$initiator==i&
                                          return_df$recipient==j&
                                          return_df$observe.id==cur_win,"event.times"][[1]]
        current_obs_time <- return_df[return_df$initiator==i&
                                        return_df$recipient==j&
                                        return_df$observe.id==cur_win,"observe.time"]
        Lambda_vec <- uniHawkesCompensator(object=param_mean, events=c(current_event_time,current_obs_time))
        all_Lambda <- c(all_Lambda,Lambda_vec)
        n_matrix[i,j] <- n_matrix[i,j] + length(current_event_time)
      }
      if(length(all_Lambda)>0){
        ks.stat.matrix[i,j] <-  ks.test(all_Lambda,"pexp",rate=1/mean(all_Lambda))$statistic
        Lambda_matrix[i,j][[1]] <- all_Lambda
      }
    }
  }
}

# png(paste(plot_path,"/diagonsis_model1_",cohort_names[current_cohort],".png",sep=''),
#     width=480,height=480)
# -------------- KS plot (stat)
col.vec <- cRamp(as.vector(ks.stat.matrix))
## need to do some sort of transformation between these here
vir_cols <- viridis::viridis(length((as.vector(ks.stat.matrix))))
#order(as.vector(ks.stat.matrix),method = "")

values <- as.vector(ks.stat.matrix)
sorted_vals <- sort(ks.stat.matrix)
#match(values,sorted_vals)
col.vec.vir <- vir_cols[match(values,sorted_vals)]

####
par(oma = c(6,4,4,1), mar=rep(0,4),
    mgp = c(0, .2, 0))
layout(cbind(matrix(data=c(1:(12*12)), nrow=12, ncol=12, byrow = TRUE),rep(12*12+1,12)), 
       widths=c(rep(1,12),2), heights=rep(1,12))
for(i in expert_rank_10[[current_cohort]]){
  for(j in expert_rank_10[[current_cohort]]){
    if(ks.stat.matrix[i,j]==0){
      plot(0,0,xlim=c(0,5),ylim=c(0,5),type="n", xlab="", ylab="", axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4], border = 0, col = 'white')
    }else{
      Lambda.test <- Lambda_matrix[i,j][[1]]
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE)
      rect(par('usr')[1],par('usr')[3],par('usr')[2],par('usr')[4], border = 0, col = col.vec.vir[matrixToVecIdx(i,j,mice_number)])
      curve(pexp(x,1/mean(Lambda.test)), min(Lambda.test), max(Lambda.test),
            ylab="",xlab="",axes = FALSE, frame=TRUE,add=TRUE, lwd=2)
      plot(ecdf(Lambda.test), add=TRUE, do.points=FALSE, verticals=TRUE,col="red", lwd=2)
    }
  }
}
par(mar = c(0,2,0,3),mgp=c(0,0.8,0))

col_obj <- list(x.vec = seq(0,max(as.vector(ks.stat.matrix)),length.out = 100),
                col.vec = viridis(100))

temp <- cLegend(as.vector(ks.stat.matrix))
#which(temp$x.vec == as.vector(ks.stat.matrix))
## need to adjust this for the legend also.
# image(1, cLegend(as.vector(ks.stat.matrix))$x.vec,
#       matrix(data=cLegend(as.vector(ks.stat.matrix))$x.vec, 
#              ncol=length(cLegend(as.vector(ks.stat.matrix))$x.vec),nrow=1),
#       col=cLegend(as.vector(ks.stat.matrix))$col.vec,
#       xlab="",ylab="",axes=FALSE)
image(1, col_obj$x.vec,
      matrix(data=col_obj$x.vec, 
             ncol=length(col_obj$x.vec),nrow=1),
      col=col_obj$col.vec,
      xlab="",ylab="",axes=FALSE)
axis(4, at=c(0,0.3,0.6), labels=c(0,0.3,0.6), las= HORIZONTAL<-1,
     cex.axis=2.4)

mtext(text=expert_rank_10[[current_cohort]], side=1, line=1.8, outer=TRUE, cex=1.8,
      at=1/14*c(1:12)-1/22)
mtext(text=expert_rank_10[[current_cohort]], side=2, line=0.5, outer=TRUE, cex=1.8,
      at=1/12*c(12:1)-1/20, las=2)
mtext(text="(b)", side=3, line=1.4, outer=TRUE, cex=2.2,
      at=0.45, font=2)
#dev.off()
```

# Figure 3: Comparison of C-HP and C-DCHP

## Figure 3a: Baseline rates


```{r fig-3a-baseline-rate}
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
gamma_mean <- apply(sim_cohort_dchp$gamma,2,mean)
zeta_mean <- apply(sim_cohort_dchp$zeta,2,mean)

# social matrix plot
latent_social_matrix <- gamma_mean%*%t(rep(1,mice_number))+rep(1,mice_number)%*%t(zeta_mean)

# png(paste(plot_path,"/lambda0_",cohort_names[current_cohort],".png",sep=''),
#     width=400, height=300)
matrixPlotParameter(latent_social_matrix[rev(expert_rank_10[[current_cohort]]),expert_rank_10[[current_cohort]]],
                    xLabels=expert_rank_10[[current_cohort]],
                    yLabels=rev(expert_rank_10[[current_cohort]]),title="(a)")
# mtext(text=c(1,2,11,6,7,9), side=1, line=-0.35, outer=TRUE, cex=1.3,
#       at=1/17.8*seq(2,12,2)+0.09)
#dev.off()
```
## Figure 3b: Ranking Comparison

```{r fig-3b-rank-comparison}
current_cohort <- 1
colors_plot <- viridis(2)
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
# png(paste(plot_path,"/rank_",cohort_names[current_cohort],".png",sep=''),
#     width=400, height=300)
par(oma = c(0,0,2,0), mar = c(3,4,1,1),mgp=c(0,0.5,0))
plot(order(expert_rank_10[[current_cohort]]),
     apply(sim_cohort_hp$f,2,mean),pch=16,cex=1.2,
     #col= "steelblue",
     col = colors_plot[1],
     ylab="",xlab="",
     xlim=c(1,12.5),ylim=c(0,1), xaxt="n", yaxt="n")
segments(order(expert_rank_10[[current_cohort]]),
         apply(sim_cohort_hp$f,2,mean)-apply(sim_cohort_hp$f,2,sd),
         order(expert_rank_10[[current_cohort]]),
         apply(sim_cohort_hp$f,2,mean)+apply(sim_cohort_hp$f,2,sd),
         #col= add.alpha("steelblue",0.8),lwd=2)
         col = add.alpha(colors_plot[1],0.8), lwd =2)
points(order(expert_rank_10[[current_cohort]])+0.2,
       apply(sim_cohort_dchp$f,2,mean),
       pch=16,cex=1.2,
       col=colors_plot[2])
       #col="goldenrod2")
segments(order(expert_rank_10[[current_cohort]])+0.2,
         apply(sim_cohort_dchp$f,2,mean)-apply(sim_cohort_dchp$f,2,sd),
         order(expert_rank_10[[current_cohort]])+0.2,
         apply(sim_cohort_dchp$f,2,mean)+apply(sim_cohort_dchp$f,2,sd),
         col= add.alpha(colors_plot[2],0.8),lwd=2)
         #col= add.alpha("goldenrod2",0.8),lwd=2)

axis(BELOW<-1, at=1:12, labels=expert_rank_10[[current_cohort]], cex.axis=1.3, tck=-0.015)
mtext(text=11, side=1, line=0.5, cex=1.3, at=6)

axis(LEFT <-2, at=seq(0,1,0.2), labels=seq(0,1,0.2), las= HORIZONTAL<-1,
     cex.axis=1.3, tck=-0.015)
mtext(side=1, text="I&SI rank", line=1.8, cex=1.5)
mtext(side=2, text="Latent rank", line=2.4, cex=1.6)
mtext(side=3, text="(b)", line=0.8, cex=1.6, font=2)
legend('bottomleft', legend = c("C-HP", "C-DCHP"),
       pch = c(16, 16), lty = c(1, 1), lwd=c(2,2),
       #col=c("steelblue","goldenrod"),
       col=c(colors_plot[1],colors_plot[2]),
       cex=1.5)
#dev.off()
```


# Figure 4:
To be added.

# Figure 5:
To be added.

# Figure 6: Latent Rank Cohort comparison


## Figure 6a: Rank vs I&SI


```{r fig-6a-rank-vs-isi}
### Rank Comparison for Single Cohort ####
current_cohort <- 1

load(paste(data_path,cohort_names[current_cohort],
           "/agg_rank_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_hp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_dchp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))
load(paste(data_path,cohort_names[current_cohort],
           "/cohort_mmhp_stan_result_",cohort_names[current_cohort],
           ".RData",sep=''))

no_method <- 4
plot_latent_df <- data.frame(Methods=rep(1:no_method,each=1000*mice_number),
                             Mice=rep(rep(1:mice_number,each=1000),no_method),
                             force=rep(0,1000*mice_number*no_method))
## agg
plot_latent_df$force[(1:(1000*mice_number))] <- as.vector(sim_agg_rank$x[1001:2000,])

## M1
plot_latent_df$force[(1:(1000*mice_number))+1000*mice_number] <- as.vector(sim_cohort_hp$f)

## M2
plot_latent_df$force[(1:(1000*mice_number))+2000*mice_number] <- as.vector(sim_cohort_dchp$f)

## M3
plot_latent_df$force[(1:(1000*mice_number))+3000*mice_number] <- as.vector(sim_cohort_mmhp$f)

plot_latent_df$Mice <- factor(plot_latent_df$Mice,
                              levels = expert_rank_10[[current_cohort]])
plot_latent_df$Method <- factor(plot_latent_df$Method,
                                labels = c("AggRanking","C-HP","C-DCHP","C-MMHP"))

# png(paste(plot_path,"real_rank_one_cohort.png",sep=""),width=600,height=300)

p1 <- ggplot(plot_latent_df, 
             aes(x = Mice, y = force, fill = Method)) +
  geom_boxplot(alpha=0.7) +
  scale_fill_manual(values = viridis::viridis(4))+
  #scale_fill_manual(values = c("gray", "steelblue", "goldenrod2" , "firebrick2")) +
  ggtitle("(a)") +
  theme_bw() +
  theme(plot.title = element_text(size = 22, hjust = 0.5, face="bold"),
        text = element_text(size = 20),
        axis.text.x=element_text(size = 10),
        legend.position="none") +
  facet_grid(cols=vars(Method)) +
  xlab("Mice (ranked by I&SI method)") +
  ylab("Latent rank")
p1
#dev.off()

```
## Figure 6b: Spearman rank correlation

Not completed. This would need the rankings to be
rerun for all cohorts.


<!-- # Figure 7: Pearson residual matrices -->

<!-- Here is where I need to be a bit more careful about using the correct fits. -->
<!-- Currently using all from Jing's saved output. -->

<!-- In the process of updating this to compute the PR for C-mmhp and I-mmhp on the cluster and simply load those matrices. -->

<!-- ```{r} -->
<!-- current_cohort <- 1 -->

<!-- m1_residual_matrix_lst <- list() -->
<!-- m2_residual_matrix_lst <- list() -->
<!-- m3_residual_matrix_lst <- list() -->
<!-- mmhp_residual_matrix_lst <- list() -->


<!--   print(current_cohort) -->
<!--   clean_data <- cleanData(full_data[[cohort_names[current_cohort]]]) -->
<!--   return_df <- cleanObservationPeriod(current_cohort, clean_data) -->
<!--   unique_pairs_df <- return_df %>% group_by(initiator, recipient) %>% -->
<!--     summarize(count=n(), -->
<!--               observe=list(observe.id), -->
<!--               observe.length=list(observe.time), -->
<!--               no.events=list(no.events)) -->
<!--   unique_observe_win <- unique(return_df[,c("observe.id","observe.time")]) -->

<!--   # M1 -->
<!--   load(paste(jing_data_path,cohort_names[current_cohort], -->
<!--              "/cohort_hp_stan_result_",cohort_names[current_cohort], -->
<!--              ".RData",sep='')) -->
<!--   model1_par_est <- list(lambda0=mean(sim_cohort_hp$lambda0), -->
<!--                          eta_1=mean(sim_cohort_hp$eta_1), -->
<!--                          eta_2=mean(sim_cohort_hp$eta_2), -->
<!--                          eta_3=mean(sim_cohort_hp$eta_3), -->
<!--                          beta=mean(sim_cohort_hp$beta), -->
<!--                          f=apply(sim_cohort_hp$f,2,mean)) -->
<!--   model1_par_matrix <- list(lambda0_matrix=matrix(model1_par_est$lambda0, -->
<!--                                                   nrow=mice_number,ncol=mice_number), -->
<!--                             alpha_matrix=formMatrix(function(x,y) model1_fn$alpha.fun(x,y, -->
<!--                                                                                       model1_par_est$eta_1, -->
<!--                                                                                       model1_par_est$eta_2, -->
<!--                                                                                       model1_par_est$eta_3), -->
<!--                                                     model1_par_est$f), -->
<!--                             beta_matrix=matrix(model1_par_est$beta, -->
<!--                                                nrow=mice_number,ncol=mice_number)) -->
<!--   m1_residual_matrix <- matrix(0,ncol=mice_number,nrow=mice_number) -->

<!--   for(i in 1:mice_number){ -->
<!--     for(j in 1:mice_number){ -->
<!--       pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j) -->
<!--       if(length(pair)>0&(i!=j)){ -->
<!--         par_est <- lapply(model1_par_matrix, function(x) x[i,j]) -->
<!--         names(par_est) <- c("lambda0","alpha","beta") -->
<!--         current_window_vec <- unique_pairs_df$observe[[pair]] -->
<!--         all_residual <- 0 -->
<!--         for(cur in c(1:length(current_window_vec))){ ## check length > 2 -->
<!--           cur_win <- current_window_vec[cur] -->
<!--           current_event_time <- return_df[return_df$initiator==i& -->
<!--                                             return_df$recipient==j& -->
<!--                                             return_df$observe.id==cur_win,"event.times"][[1]] -->
<!--           current_obs_time <- return_df[return_df$initiator==i& -->
<!--                                           return_df$recipient==j& -->
<!--                                           return_df$observe.id==cur_win,"observe.time"] -->
<!--           all_residual <- all_residual + uniHawkesPearsonResidual(object=par_est, -->
<!--                                                                   events=current_event_time, -->
<!--                                                                   termination = current_obs_time) -->
<!--         } -->
<!--         m1_residual_matrix[i,j] <- all_residual -->
<!--       } -->
<!--     } -->
<!--   } -->

<!--   # M2 -->
<!--   load(paste(jing_data_path,cohort_names[current_cohort], -->
<!--              "/cohort_dchp_stan_result_",cohort_names[current_cohort], -->
<!--              ".RData",sep='')) -->
<!--   model2_par_est <- list(gamma=apply(sim_cohort_dchp$gamma,2,mean), -->
<!--                          zeta=apply(sim_cohort_dchp$zeta,2,mean), -->
<!--                          eta_1=mean(sim_cohort_dchp$eta_1), -->
<!--                          eta_2=mean(sim_cohort_dchp$eta_2), -->
<!--                          eta_3=mean(sim_cohort_dchp$eta_3), -->
<!--                          beta=mean(sim_cohort_dchp$beta), -->
<!--                          f=apply(sim_cohort_dchp$f,2,mean)) -->
<!--   model2_par_matrix <- list(lambda0_matrix=model2_par_est$gamma%*%t(rep(1,mice_number))+ -->
<!--                               rep(1,mice_number)%*%t(model2_par_est$zeta), -->
<!--                             alpha_matrix=formMatrix(function(x,y) model1_fn$alpha.fun(x,y, -->
<!--                                                                                       model2_par_est$eta_1, -->
<!--                                                                                       model2_par_est$eta_2, -->
<!--                                                                                       model2_par_est$eta_3), -->
<!--                                                     model2_par_est$f), -->
<!--                             beta_matrix=matrix(model2_par_est$beta, -->
<!--                                                nrow=mice_number,ncol=mice_number)) -->
<!--   m2_residual_matrix <- matrix(0,ncol=mice_number,nrow=mice_number) -->

<!--   for(i in 1:mice_number){ -->
<!--     for(j in 1:mice_number){ -->
<!--       pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j) -->
<!--       if(length(pair)>0&(i!=j)){ -->
<!--         par_est <- lapply(model2_par_matrix, function(x) x[i,j]) -->
<!--         names(par_est) <- c("lambda0","alpha","beta") -->
<!--         current_window_vec <- unique_pairs_df$observe[[pair]] -->
<!--         all_residual <- 0 -->
<!--         for(cur in c(1:length(current_window_vec))){  -->
<!--           cur_win <- current_window_vec[cur] -->
<!--           current_event_time <- return_df[return_df$initiator==i& -->
<!--                                             return_df$recipient==j& -->
<!--                                             return_df$observe.id==cur_win,"event.times"][[1]] -->
<!--           current_obs_time <- return_df[return_df$initiator==i& -->
<!--                                           return_df$recipient==j& -->
<!--                                           return_df$observe.id==cur_win,"observe.time"] -->
<!--           all_residual <- all_residual + uniHawkesPearsonResidual(object=par_est, -->
<!--                                                                   events=current_event_time, -->
<!--                                                                   termination = current_obs_time) -->
<!--         } -->
<!--         m2_residual_matrix[i,j] <- all_residual -->
<!--       } -->
<!--     } -->
<!--   } -->

<!-- ```   -->

<!-- This is too large to load at the moment again. Can do this on the cluster. -->

<!-- ```{r, eval=FALSE}   -->
<!--   # M3 -->
<!--   load(paste(jing_data_path,cohort_names[current_cohort], -->
<!--              "/cohort_mmhp_stan_result_",cohort_names[current_cohort], -->
<!--              ".RData",sep='')) -->
<!--   load(paste(jing_data_path,cohort_names[current_cohort], -->
<!--              "/cmmhp_est_zt_",cohort_names[current_cohort],".RData",sep='')) -->
<!--   model3_par_est <- list(lambda0=mean(sim_cohort_mmhp$lambda0), -->
<!--                          lambda1=mean(sim_cohort_mmhp$lambda1), -->
<!--                          eta_1=mean(sim_cohort_mmhp$eta_1), -->
<!--                          eta_2=mean(sim_cohort_mmhp$eta_2), -->
<!--                          eta_3=mean(sim_cohort_mmhp$eta_3), -->
<!--                          beta=mean(sim_cohort_mmhp$beta), -->
<!--                          f=apply(sim_cohort_mmhp$f,2,mean)) -->
<!--   model3_par_matrix <- list(lambda0_matrix=matrix(model3_par_est$lambda0, -->
<!--                                                   nrow=mice_number,ncol=mice_number), -->
<!--                             lambda1_matrix=matrix(model3_par_est$lambda1, -->
<!--                                                   nrow=mice_number,ncol=mice_number), -->
<!--                             alpha_matrix=formMatrix(function(x,y) model3_fn$alpha.fun(x,y, -->
<!--                                                                                       model3_par_est$eta_1, -->
<!--                                                                                       model3_par_est$eta_2), -->
<!--                                                     model3_par_est$f), -->
<!--                             beta_matrix=matrix(model3_par_est$beta, -->
<!--                                                nrow=mice_number,ncol=mice_number), -->
<!--                             q1_matrix=formMatrix(function(x,y) model3_fn$q1.fun(x,y,model3_par_est$eta_3), -->
<!--                                                  model3_par_est$f), -->
<!--                             q2_matrix=formMatrix(function(x,y) model3_fn$q0.fun(x,y,model3_par_est$eta_3), -->
<!--                                                  model3_par_est$f)) -->
<!--   m3_residual_matrix <- matrix(0,ncol=mice_number,nrow=mice_number) -->
<!--   no_segments <- 5000 # changed from 5000 -->
<!--   window_pr <- c() -->
<!--   for(i in 1:mice_number){ -->
<!--     print(i) -->
<!--     for(j in 1:mice_number){ -->
<!--       pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j) -->
<!--       if(length(pair)>0&(i!=j)){ -->
<!--         par_est <- lapply(model3_par_matrix, function(x) x[i,j]) -->
<!--         names(par_est) <- c("lambda0","lambda1","alpha","beta","q1","q2") -->
<!--         current_window_vec <- unique_pairs_df$observe[[pair]] -->
<!--         all_residual <- 0 -->
<!--         for(cur in c(1:length(current_window_vec))){ ## check length > 2 -->
<!--           cur_win <- current_window_vec[cur] -->
<!--           current_event_time <- return_df[return_df$initiator==i& -->
<!--                                             return_df$recipient==j& -->
<!--                                             return_df$observe.id==cur_win,"event.times"][[1]] -->
<!--           current_obs_time <- return_df[return_df$initiator==i& -->
<!--                                           return_df$recipient==j& -->
<!--                                           return_df$observe.id==cur_win,"observe.time"] -->
<!--           time_segment <- seq(0,current_obs_time,length.out=no_segments) -->
<!--           latent_mean <- apply(interpolation_array_list[[pair]][[cur_win]],1,mean) -->
<!--           latent_event <- as.numeric(apply(2-state_array_list[[pair]][[cur_win]],1,mean) > 0.5)  -->
<!--           est.intensity <- mmhpIntensityNumeric(params=par_est, -->
<!--                                                 t=current_event_time, -->
<!--                                                 time.vec=time_segment, -->
<!--                                                 latent.vec=latent_mean) -->
<!--           est.intensity.events <- mmhpIntensityAtEvents(params=par_est, t=current_event_time, -->
<!--                                                         latent_z=latent_event) -->
<!--           all_residual <- all_residual + sum(1/sqrt(est.intensity.events))- -->
<!--             sum(sqrt(est.intensity))*(time_segment[2]-time_segment[1]) -->
<!--           # print(sum(1/sqrt(est.intensity.events))- -->
<!--           #         sum(sqrt(est.intensity))*(time_segment[2]-time_segment[1])) -->
<!--           # print(summary(latent_mean)) -->
<!--           # window_pr <- c(window_pr,sum(1/sqrt(est.intensity.events))- -->
<!--           #                  sum(sqrt(est.intensity))*(time_segment[2]-time_segment[1])) -->
<!--         } -->
<!--         m3_residual_matrix[i,j] <- all_residual -->
<!--       } -->
<!--     } -->
<!--   } -->

<!-- ```   -->
<!-- These are in part 1 of the thesis folder on Google Drive. -->

<!-- ```{r, eval=FALSE} -->
<!-- ind_mmhp_data_path <- "C:/Users/owenw/Google Drive/Tian/Research+JingWu/thesis_data/part1/real_data/" -->
<!--   # Independent MMHP -->
<!--   load(paste(ind_mmhp_data_path, cohort_names[current_cohort],  -->
<!--              "/sep_mmhp_stan_result_", cohort_names[current_cohort],".RData",sep='')) -->
<!--   load(paste(ind_mmhp_data_path,cohort_names[current_cohort], -->
<!--              "/mmhp_est_zt_",cohort_names[current_cohort],".RData",sep='')) -->

<!--   mmhp_residual_matrix <- matrix(0,ncol=mice_number,nrow=mice_number) -->
<!--   for(i in 1:mice_number){ -->
<!--     print(i) -->
<!--     for(j in 1:mice_number){ -->
<!--       pair <- which(unique_pairs_df$initiator==i&unique_pairs_df$recipient==j) -->
<!--       if(length(pair)>0&(i!=j)){ -->
<!--         par_est <- list(lambda0=mean(sim_mmhp_sep$lambda0[,pair]), -->
<!--                         lambda1=mean(sim_mmhp_sep$lambda1[,pair]), -->
<!--                         alpha=mean(sim_mmhp_sep$alpha[,pair]), -->
<!--                         beta=mean(sim_mmhp_sep$beta[,pair]), -->
<!--                         q1=mean(sim_mmhp_sep$q1[,pair]), -->
<!--                         q2=mean(sim_mmhp_sep$q2[,pair])) -->
<!--         current_window_vec <- unique_pairs_df$observe[[pair]] -->
<!--         all_residual <- 0 -->
<!--         for(cur in c(1:length(current_window_vec))){ ## check length > 2 -->
<!--           cur_win <- current_window_vec[cur] -->
<!--           current_event_time <- return_df[return_df$initiator==i& -->
<!--                                             return_df$recipient==j& -->
<!--                                             return_df$observe.id==cur_win,"event.times"][[1]] -->
<!--           current_obs_time <- return_df[return_df$initiator==i& -->
<!--                                           return_df$recipient==j& -->
<!--                                           return_df$observe.id==cur_win,"observe.time"] -->
<!--           time_segment <- seq(0,current_obs_time,length.out=no_segments) -->
<!--           latent_mean <- apply(interpolation_array_list[[pair]][[cur_win]],1,mean) -->
<!--           latent_event <- as.numeric(apply(2-state_array_list[[pair]][[cur_win]],1,mean) > 0.5)  -->
<!--           est.intensity <- mmhpIntensityNumeric(params=par_est, -->
<!--                                                 t=current_event_time, -->
<!--                                                 time.vec=time_segment, -->
<!--                                                 latent.vec=latent_mean) -->
<!--           est.intensity.events <- mmhpIntensityAtEvents(params=par_est, t=current_event_time, -->
<!--                                                         latent_z=latent_event) -->
<!--           all_residual <- all_residual + sum(1/sqrt(est.intensity.events))- -->
<!--             sum(sqrt(est.intensity))*(time_segment[2]-time_segment[1]) -->
<!--         } -->
<!--         mmhp_residual_matrix[i,j] <- all_residual -->
<!--       } -->
<!--     } -->
<!--   } -->
<!--   m1_residual_matrix_lst[[current_cohort]] <- m1_residual_matrix -->
<!--   m2_residual_matrix_lst[[current_cohort]] <- m2_residual_matrix -->
<!--   m3_residual_matrix_lst[[current_cohort]] <- m3_residual_matrix -->
<!--   mmhp_residual_matrix_lst[[current_cohort]] <- mmhp_residual_matrix -->


<!-- save(m1_residual_matrix_lst, m2_residual_matrix_lst, m3_residual_matrix_lst, mmhp_residual_matrix_lst, -->
<!--      file = "C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/plots/pearson_residual_cohort9.RData") -->
<!-- beepr::beep() -->
<!-- ``` -->
<!-- These would need to be rerun correctly and saved. -->
<!-- For now using an *old* version. -->

<!-- ```{r} -->
<!-- load("C:/Users/owenw/Google Drive/Tian/Current_Projects/MMHP_Latent/plots/pearson_residual_cohort9.RData") -->
<!-- png(paste(plot_path,"real_residual_matrix_one_cohort.png",sep=""),width = 800,height = 400) -->
<!-- matrix_lst_plot <- list( -->
<!--                         mmhp_residual_matrix_lst[[current_cohort]][rev(expert_rank_10[[current_cohort]]), -->
<!--                                                                    expert_rank_10[[current_cohort]]], -->
<!--                         m1_residual_matrix_lst[[current_cohort]][rev(expert_rank_10[[current_cohort]]), -->
<!--                                                                  expert_rank_10[[current_cohort]]], -->
<!--                         m2_residual_matrix_lst[[current_cohort]][rev(expert_rank_10[[current_cohort]]), -->
<!--                                                                  expert_rank_10[[current_cohort]]], -->
<!--                         m3_residual_matrix_lst[[current_cohort]][rev(expert_rank_10[[current_cohort]]), -->
<!--                                                                  expert_rank_10[[current_cohort]]])  -->
<!-- myMultiMatrixPlot(X=matrix_lst_plot,no_matrix=4,n_row=2, -->
<!--                   xLabels=expert_rank_10[[current_cohort]], -->
<!--                   yLabels=rev(expert_rank_10[[current_cohort]]), -->
<!--                   min=-63,max=63,axis_cex=2,title_cex = 1.8, -->
<!--                   colorPalette="RdBu",if.emp=FALSE,legend.mar=c(0.5,.5,0.5,0.95), -->
<!--                   title_lst=list("I-MMHP","C-HP","C-DCHP","C-MMHP"),  -->
<!--                   #title_lst = list("I-MMHP"), -->
<!--                   col_axis=c(-60,-30,0,30,60), out.title="", fake_matrix=FALSE, -->
<!--                   matrix.mar=c(2.5,2.5,2.5,2)) -->
<!-- dev.off() -->
<!-- ``` -->
<!-- The remaining plot code seems to mostly be in `PaperPlots.R`. -->

<!-- # Figure 8 -->

<!-- ## Figure 8a: Frobenius norm of interaction predictions, single cohort -->

<!-- ## Figure 8b: Same plot aggregated for all cohorts -->

<!-- # Figure 9 -->

<!-- ## Figure 9a: Predicted Spearman rank for single cohort -->

<!-- ## Figure 9b: Predicted Spearman rank for all cohorts -->

<!-- # Figure 10 -->

